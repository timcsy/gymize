// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: space.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_space_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_space_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_space_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_space_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_space_2eproto;
class GraphProto;
struct GraphProtoDefaultTypeInternal;
extern GraphProtoDefaultTypeInternal _GraphProto_default_instance_;
class ImageProto;
struct ImageProtoDefaultTypeInternal;
extern ImageProtoDefaultTypeInternal _ImageProto_default_instance_;
class InstanceProto;
struct InstanceProtoDefaultTypeInternal;
extern InstanceProtoDefaultTypeInternal _InstanceProto_default_instance_;
class InstanceProto_DictEntry_DoNotUse;
struct InstanceProto_DictEntry_DoNotUseDefaultTypeInternal;
extern InstanceProto_DictEntry_DoNotUseDefaultTypeInternal _InstanceProto_DictEntry_DoNotUse_default_instance_;
class TensorProto;
struct TensorProtoDefaultTypeInternal;
extern TensorProtoDefaultTypeInternal _TensorProto_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::GraphProto* Arena::CreateMaybeMessage<::GraphProto>(Arena*);
template<> ::ImageProto* Arena::CreateMaybeMessage<::ImageProto>(Arena*);
template<> ::InstanceProto* Arena::CreateMaybeMessage<::InstanceProto>(Arena*);
template<> ::InstanceProto_DictEntry_DoNotUse* Arena::CreateMaybeMessage<::InstanceProto_DictEntry_DoNotUse>(Arena*);
template<> ::TensorProto* Arena::CreateMaybeMessage<::TensorProto>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum CompressionTypeProto : int {
  COMPRESSION_TYPE_PROTO_UNSPECIFIED = 0,
  COMPRESSION_TYPE_PROTO_NONE = 1,
  COMPRESSION_TYPE_PROTO_PNG = 2,
  COMPRESSION_TYPE_PROTO_JPG = 3,
  CompressionTypeProto_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CompressionTypeProto_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CompressionTypeProto_IsValid(int value);
constexpr CompressionTypeProto CompressionTypeProto_MIN = COMPRESSION_TYPE_PROTO_UNSPECIFIED;
constexpr CompressionTypeProto CompressionTypeProto_MAX = COMPRESSION_TYPE_PROTO_JPG;
constexpr int CompressionTypeProto_ARRAYSIZE = CompressionTypeProto_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompressionTypeProto_descriptor();
template<typename T>
inline const std::string& CompressionTypeProto_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompressionTypeProto>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompressionTypeProto_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CompressionTypeProto_descriptor(), enum_t_value);
}
inline bool CompressionTypeProto_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CompressionTypeProto* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CompressionTypeProto>(
    CompressionTypeProto_descriptor(), name, value);
}
enum InstanceTypeProto : int {
  INSTANCE_TYPE_PROTO_UNSPECIFIED = 0,
  INSTANCE_TYPE_PROTO_RAW = 1,
  INSTANCE_TYPE_PROTO_TENSOR = 2,
  INSTANCE_TYPE_PROTO_DISCRETE = 3,
  INSTANCE_TYPE_PROTO_TEXT = 4,
  INSTANCE_TYPE_PROTO_DICT = 5,
  INSTANCE_TYPE_PROTO_LIST = 6,
  INSTANCE_TYPE_PROTO_GRAPH = 7,
  INSTANCE_TYPE_PROTO_IMAGE = 8,
  INSTANCE_TYPE_PROTO_FLOAT = 9,
  INSTANCE_TYPE_PROTO_BOOL = 10,
  INSTANCE_TYPE_PROTO_NULL = 11,
  INSTANCE_TYPE_PROTO_JSON = 12,
  InstanceTypeProto_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  InstanceTypeProto_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool InstanceTypeProto_IsValid(int value);
constexpr InstanceTypeProto InstanceTypeProto_MIN = INSTANCE_TYPE_PROTO_UNSPECIFIED;
constexpr InstanceTypeProto InstanceTypeProto_MAX = INSTANCE_TYPE_PROTO_JSON;
constexpr int InstanceTypeProto_ARRAYSIZE = InstanceTypeProto_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InstanceTypeProto_descriptor();
template<typename T>
inline const std::string& InstanceTypeProto_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InstanceTypeProto>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InstanceTypeProto_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InstanceTypeProto_descriptor(), enum_t_value);
}
inline bool InstanceTypeProto_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InstanceTypeProto* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InstanceTypeProto>(
    InstanceTypeProto_descriptor(), name, value);
}
// ===================================================================

class TensorProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TensorProto) */ {
 public:
  inline TensorProto() : TensorProto(nullptr) {}
  ~TensorProto() override;
  explicit constexpr TensorProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TensorProto(const TensorProto& from);
  TensorProto(TensorProto&& from) noexcept
    : TensorProto() {
    *this = ::std::move(from);
  }

  inline TensorProto& operator=(const TensorProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorProto& operator=(TensorProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TensorProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TensorProto* internal_default_instance() {
    return reinterpret_cast<const TensorProto*>(
               &_TensorProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TensorProto& a, TensorProto& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TensorProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TensorProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TensorProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TensorProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TensorProto& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TensorProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TensorProto";
  }
  protected:
  explicit TensorProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 3,
    kDataFieldNumber = 1,
    kDtypeFieldNumber = 2,
  };
  // repeated int32 shape = 3;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int32_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_shape() const;
  void _internal_add_shape(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_shape();
  public:
  int32_t shape(int index) const;
  void set_shape(int index, int32_t value);
  void add_shape(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_shape();

  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string dtype = 2;
  void clear_dtype();
  const std::string& dtype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dtype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dtype();
  PROTOBUF_NODISCARD std::string* release_dtype();
  void set_allocated_dtype(std::string* dtype);
  private:
  const std::string& _internal_dtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dtype(const std::string& value);
  std::string* _internal_mutable_dtype();
  public:

  // @@protoc_insertion_point(class_scope:TensorProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > shape_;
  mutable std::atomic<int> _shape_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dtype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_space_2eproto;
};
// -------------------------------------------------------------------

class GraphProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GraphProto) */ {
 public:
  inline GraphProto() : GraphProto(nullptr) {}
  ~GraphProto() override;
  explicit constexpr GraphProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GraphProto(const GraphProto& from);
  GraphProto(GraphProto&& from) noexcept
    : GraphProto() {
    *this = ::std::move(from);
  }

  inline GraphProto& operator=(const GraphProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphProto& operator=(GraphProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphProto* internal_default_instance() {
    return reinterpret_cast<const GraphProto*>(
               &_GraphProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GraphProto& a, GraphProto& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraphProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GraphProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GraphProto& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GraphProto";
  }
  protected:
  explicit GraphProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
    kEdgesFieldNumber = 2,
    kEdgeLinksFieldNumber = 3,
  };
  // .TensorProto nodes = 1;
  bool has_nodes() const;
  private:
  bool _internal_has_nodes() const;
  public:
  void clear_nodes();
  const ::TensorProto& nodes() const;
  PROTOBUF_NODISCARD ::TensorProto* release_nodes();
  ::TensorProto* mutable_nodes();
  void set_allocated_nodes(::TensorProto* nodes);
  private:
  const ::TensorProto& _internal_nodes() const;
  ::TensorProto* _internal_mutable_nodes();
  public:
  void unsafe_arena_set_allocated_nodes(
      ::TensorProto* nodes);
  ::TensorProto* unsafe_arena_release_nodes();

  // .TensorProto edges = 2;
  bool has_edges() const;
  private:
  bool _internal_has_edges() const;
  public:
  void clear_edges();
  const ::TensorProto& edges() const;
  PROTOBUF_NODISCARD ::TensorProto* release_edges();
  ::TensorProto* mutable_edges();
  void set_allocated_edges(::TensorProto* edges);
  private:
  const ::TensorProto& _internal_edges() const;
  ::TensorProto* _internal_mutable_edges();
  public:
  void unsafe_arena_set_allocated_edges(
      ::TensorProto* edges);
  ::TensorProto* unsafe_arena_release_edges();

  // .TensorProto edge_links = 3;
  bool has_edge_links() const;
  private:
  bool _internal_has_edge_links() const;
  public:
  void clear_edge_links();
  const ::TensorProto& edge_links() const;
  PROTOBUF_NODISCARD ::TensorProto* release_edge_links();
  ::TensorProto* mutable_edge_links();
  void set_allocated_edge_links(::TensorProto* edge_links);
  private:
  const ::TensorProto& _internal_edge_links() const;
  ::TensorProto* _internal_mutable_edge_links();
  public:
  void unsafe_arena_set_allocated_edge_links(
      ::TensorProto* edge_links);
  ::TensorProto* unsafe_arena_release_edge_links();

  // @@protoc_insertion_point(class_scope:GraphProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::TensorProto* nodes_;
  ::TensorProto* edges_;
  ::TensorProto* edge_links_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_space_2eproto;
};
// -------------------------------------------------------------------

class ImageProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ImageProto) */ {
 public:
  inline ImageProto() : ImageProto(nullptr) {}
  ~ImageProto() override;
  explicit constexpr ImageProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageProto(const ImageProto& from);
  ImageProto(ImageProto&& from) noexcept
    : ImageProto() {
    *this = ::std::move(from);
  }

  inline ImageProto& operator=(const ImageProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageProto& operator=(ImageProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageProto* internal_default_instance() {
    return reinterpret_cast<const ImageProto*>(
               &_ImageProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ImageProto& a, ImageProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ImageProto& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ImageProto";
  }
  protected:
  explicit ImageProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 4,
    kTransposeAxesFieldNumber = 5,
    kDataFieldNumber = 2,
    kDtypeFieldNumber = 3,
    kCompressionTypeFieldNumber = 1,
  };
  // repeated int32 shape = 4;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int32_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_shape() const;
  void _internal_add_shape(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_shape();
  public:
  int32_t shape(int index) const;
  void set_shape(int index, int32_t value);
  void add_shape(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_shape();

  // repeated int32 transpose_axes = 5;
  int transpose_axes_size() const;
  private:
  int _internal_transpose_axes_size() const;
  public:
  void clear_transpose_axes();
  private:
  int32_t _internal_transpose_axes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_transpose_axes() const;
  void _internal_add_transpose_axes(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_transpose_axes();
  public:
  int32_t transpose_axes(int index) const;
  void set_transpose_axes(int index, int32_t value);
  void add_transpose_axes(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      transpose_axes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_transpose_axes();

  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string dtype = 3;
  void clear_dtype();
  const std::string& dtype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dtype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dtype();
  PROTOBUF_NODISCARD std::string* release_dtype();
  void set_allocated_dtype(std::string* dtype);
  private:
  const std::string& _internal_dtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dtype(const std::string& value);
  std::string* _internal_mutable_dtype();
  public:

  // .CompressionTypeProto compression_type = 1;
  void clear_compression_type();
  ::CompressionTypeProto compression_type() const;
  void set_compression_type(::CompressionTypeProto value);
  private:
  ::CompressionTypeProto _internal_compression_type() const;
  void _internal_set_compression_type(::CompressionTypeProto value);
  public:

  // @@protoc_insertion_point(class_scope:ImageProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > shape_;
  mutable std::atomic<int> _shape_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > transpose_axes_;
  mutable std::atomic<int> _transpose_axes_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dtype_;
  int compression_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_space_2eproto;
};
// -------------------------------------------------------------------

class InstanceProto_DictEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InstanceProto_DictEntry_DoNotUse, 
    std::string, ::InstanceProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InstanceProto_DictEntry_DoNotUse, 
    std::string, ::InstanceProto,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  InstanceProto_DictEntry_DoNotUse();
  explicit constexpr InstanceProto_DictEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit InstanceProto_DictEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const InstanceProto_DictEntry_DoNotUse& other);
  static const InstanceProto_DictEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const InstanceProto_DictEntry_DoNotUse*>(&_InstanceProto_DictEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "InstanceProto.DictEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class InstanceProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:InstanceProto) */ {
 public:
  inline InstanceProto() : InstanceProto(nullptr) {}
  ~InstanceProto() override;
  explicit constexpr InstanceProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstanceProto(const InstanceProto& from);
  InstanceProto(InstanceProto&& from) noexcept
    : InstanceProto() {
    *this = ::std::move(from);
  }

  inline InstanceProto& operator=(const InstanceProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstanceProto& operator=(InstanceProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstanceProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstanceProto* internal_default_instance() {
    return reinterpret_cast<const InstanceProto*>(
               &_InstanceProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(InstanceProto& a, InstanceProto& b) {
    a.Swap(&b);
  }
  inline void Swap(InstanceProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstanceProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstanceProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstanceProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstanceProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InstanceProto& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstanceProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "InstanceProto";
  }
  protected:
  explicit InstanceProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDictFieldNumber = 6,
    kListFieldNumber = 7,
    kRawDataFieldNumber = 2,
    kTextFieldNumber = 5,
    kJsonFieldNumber = 12,
    kTensorFieldNumber = 3,
    kGraphFieldNumber = 8,
    kImageFieldNumber = 9,
    kDiscreteFieldNumber = 4,
    kTypeFieldNumber = 1,
    kBooleanFieldNumber = 11,
    kFloatFieldNumber = 10,
  };
  // map<string, .InstanceProto> dict = 6;
  int dict_size() const;
  private:
  int _internal_dict_size() const;
  public:
  void clear_dict();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::InstanceProto >&
      _internal_dict() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::InstanceProto >*
      _internal_mutable_dict();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::InstanceProto >&
      dict() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::InstanceProto >*
      mutable_dict();

  // repeated .InstanceProto list = 7;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::InstanceProto* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InstanceProto >*
      mutable_list();
  private:
  const ::InstanceProto& _internal_list(int index) const;
  ::InstanceProto* _internal_add_list();
  public:
  const ::InstanceProto& list(int index) const;
  ::InstanceProto* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InstanceProto >&
      list() const;

  // bytes raw_data = 2;
  void clear_raw_data();
  const std::string& raw_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_raw_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_raw_data();
  PROTOBUF_NODISCARD std::string* release_raw_data();
  void set_allocated_raw_data(std::string* raw_data);
  private:
  const std::string& _internal_raw_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_data(const std::string& value);
  std::string* _internal_mutable_raw_data();
  public:

  // string text = 5;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // string json = 12;
  void clear_json();
  const std::string& json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_json();
  PROTOBUF_NODISCARD std::string* release_json();
  void set_allocated_json(std::string* json);
  private:
  const std::string& _internal_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_json(const std::string& value);
  std::string* _internal_mutable_json();
  public:

  // .TensorProto tensor = 3;
  bool has_tensor() const;
  private:
  bool _internal_has_tensor() const;
  public:
  void clear_tensor();
  const ::TensorProto& tensor() const;
  PROTOBUF_NODISCARD ::TensorProto* release_tensor();
  ::TensorProto* mutable_tensor();
  void set_allocated_tensor(::TensorProto* tensor);
  private:
  const ::TensorProto& _internal_tensor() const;
  ::TensorProto* _internal_mutable_tensor();
  public:
  void unsafe_arena_set_allocated_tensor(
      ::TensorProto* tensor);
  ::TensorProto* unsafe_arena_release_tensor();

  // .GraphProto graph = 8;
  bool has_graph() const;
  private:
  bool _internal_has_graph() const;
  public:
  void clear_graph();
  const ::GraphProto& graph() const;
  PROTOBUF_NODISCARD ::GraphProto* release_graph();
  ::GraphProto* mutable_graph();
  void set_allocated_graph(::GraphProto* graph);
  private:
  const ::GraphProto& _internal_graph() const;
  ::GraphProto* _internal_mutable_graph();
  public:
  void unsafe_arena_set_allocated_graph(
      ::GraphProto* graph);
  ::GraphProto* unsafe_arena_release_graph();

  // .ImageProto image = 9;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::ImageProto& image() const;
  PROTOBUF_NODISCARD ::ImageProto* release_image();
  ::ImageProto* mutable_image();
  void set_allocated_image(::ImageProto* image);
  private:
  const ::ImageProto& _internal_image() const;
  ::ImageProto* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::ImageProto* image);
  ::ImageProto* unsafe_arena_release_image();

  // int64 discrete = 4;
  void clear_discrete();
  int64_t discrete() const;
  void set_discrete(int64_t value);
  private:
  int64_t _internal_discrete() const;
  void _internal_set_discrete(int64_t value);
  public:

  // .InstanceTypeProto type = 1;
  void clear_type();
  ::InstanceTypeProto type() const;
  void set_type(::InstanceTypeProto value);
  private:
  ::InstanceTypeProto _internal_type() const;
  void _internal_set_type(::InstanceTypeProto value);
  public:

  // bool boolean = 11;
  void clear_boolean();
  bool boolean() const;
  void set_boolean(bool value);
  private:
  bool _internal_boolean() const;
  void _internal_set_boolean(bool value);
  public:

  // double float = 10;
  void clear_float_();
  double float_() const;
  void set_float_(double value);
  private:
  double _internal_float_() const;
  void _internal_set_float_(double value);
  public:

  // @@protoc_insertion_point(class_scope:InstanceProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      InstanceProto_DictEntry_DoNotUse,
      std::string, ::InstanceProto,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> dict_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InstanceProto > list_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr json_;
  ::TensorProto* tensor_;
  ::GraphProto* graph_;
  ::ImageProto* image_;
  int64_t discrete_;
  int type_;
  bool boolean_;
  double float__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_space_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TensorProto

// bytes data = 1;
inline void TensorProto::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& TensorProto::data() const {
  // @@protoc_insertion_point(field_get:TensorProto.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TensorProto::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TensorProto.data)
}
inline std::string* TensorProto::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:TensorProto.data)
  return _s;
}
inline const std::string& TensorProto::_internal_data() const {
  return data_.Get();
}
inline void TensorProto::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TensorProto::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TensorProto::release_data() {
  // @@protoc_insertion_point(field_release:TensorProto.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TensorProto::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TensorProto.data)
}

// string dtype = 2;
inline void TensorProto::clear_dtype() {
  dtype_.ClearToEmpty();
}
inline const std::string& TensorProto::dtype() const {
  // @@protoc_insertion_point(field_get:TensorProto.dtype)
  return _internal_dtype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TensorProto::set_dtype(ArgT0&& arg0, ArgT... args) {
 
 dtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TensorProto.dtype)
}
inline std::string* TensorProto::mutable_dtype() {
  std::string* _s = _internal_mutable_dtype();
  // @@protoc_insertion_point(field_mutable:TensorProto.dtype)
  return _s;
}
inline const std::string& TensorProto::_internal_dtype() const {
  return dtype_.Get();
}
inline void TensorProto::_internal_set_dtype(const std::string& value) {
  
  dtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TensorProto::_internal_mutable_dtype() {
  
  return dtype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TensorProto::release_dtype() {
  // @@protoc_insertion_point(field_release:TensorProto.dtype)
  return dtype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TensorProto::set_allocated_dtype(std::string* dtype) {
  if (dtype != nullptr) {
    
  } else {
    
  }
  dtype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dtype,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dtype_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    dtype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TensorProto.dtype)
}

// repeated int32 shape = 3;
inline int TensorProto::_internal_shape_size() const {
  return shape_.size();
}
inline int TensorProto::shape_size() const {
  return _internal_shape_size();
}
inline void TensorProto::clear_shape() {
  shape_.Clear();
}
inline int32_t TensorProto::_internal_shape(int index) const {
  return shape_.Get(index);
}
inline int32_t TensorProto::shape(int index) const {
  // @@protoc_insertion_point(field_get:TensorProto.shape)
  return _internal_shape(index);
}
inline void TensorProto::set_shape(int index, int32_t value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:TensorProto.shape)
}
inline void TensorProto::_internal_add_shape(int32_t value) {
  shape_.Add(value);
}
inline void TensorProto::add_shape(int32_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:TensorProto.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TensorProto::_internal_shape() const {
  return shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
TensorProto::shape() const {
  // @@protoc_insertion_point(field_list:TensorProto.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TensorProto::_internal_mutable_shape() {
  return &shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
TensorProto::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:TensorProto.shape)
  return _internal_mutable_shape();
}

// -------------------------------------------------------------------

// GraphProto

// .TensorProto nodes = 1;
inline bool GraphProto::_internal_has_nodes() const {
  return this != internal_default_instance() && nodes_ != nullptr;
}
inline bool GraphProto::has_nodes() const {
  return _internal_has_nodes();
}
inline void GraphProto::clear_nodes() {
  if (GetArenaForAllocation() == nullptr && nodes_ != nullptr) {
    delete nodes_;
  }
  nodes_ = nullptr;
}
inline const ::TensorProto& GraphProto::_internal_nodes() const {
  const ::TensorProto* p = nodes_;
  return p != nullptr ? *p : reinterpret_cast<const ::TensorProto&>(
      ::_TensorProto_default_instance_);
}
inline const ::TensorProto& GraphProto::nodes() const {
  // @@protoc_insertion_point(field_get:GraphProto.nodes)
  return _internal_nodes();
}
inline void GraphProto::unsafe_arena_set_allocated_nodes(
    ::TensorProto* nodes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nodes_);
  }
  nodes_ = nodes;
  if (nodes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GraphProto.nodes)
}
inline ::TensorProto* GraphProto::release_nodes() {
  
  ::TensorProto* temp = nodes_;
  nodes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TensorProto* GraphProto::unsafe_arena_release_nodes() {
  // @@protoc_insertion_point(field_release:GraphProto.nodes)
  
  ::TensorProto* temp = nodes_;
  nodes_ = nullptr;
  return temp;
}
inline ::TensorProto* GraphProto::_internal_mutable_nodes() {
  
  if (nodes_ == nullptr) {
    auto* p = CreateMaybeMessage<::TensorProto>(GetArenaForAllocation());
    nodes_ = p;
  }
  return nodes_;
}
inline ::TensorProto* GraphProto::mutable_nodes() {
  ::TensorProto* _msg = _internal_mutable_nodes();
  // @@protoc_insertion_point(field_mutable:GraphProto.nodes)
  return _msg;
}
inline void GraphProto::set_allocated_nodes(::TensorProto* nodes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete nodes_;
  }
  if (nodes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TensorProto>::GetOwningArena(nodes);
    if (message_arena != submessage_arena) {
      nodes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodes, submessage_arena);
    }
    
  } else {
    
  }
  nodes_ = nodes;
  // @@protoc_insertion_point(field_set_allocated:GraphProto.nodes)
}

// .TensorProto edges = 2;
inline bool GraphProto::_internal_has_edges() const {
  return this != internal_default_instance() && edges_ != nullptr;
}
inline bool GraphProto::has_edges() const {
  return _internal_has_edges();
}
inline void GraphProto::clear_edges() {
  if (GetArenaForAllocation() == nullptr && edges_ != nullptr) {
    delete edges_;
  }
  edges_ = nullptr;
}
inline const ::TensorProto& GraphProto::_internal_edges() const {
  const ::TensorProto* p = edges_;
  return p != nullptr ? *p : reinterpret_cast<const ::TensorProto&>(
      ::_TensorProto_default_instance_);
}
inline const ::TensorProto& GraphProto::edges() const {
  // @@protoc_insertion_point(field_get:GraphProto.edges)
  return _internal_edges();
}
inline void GraphProto::unsafe_arena_set_allocated_edges(
    ::TensorProto* edges) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(edges_);
  }
  edges_ = edges;
  if (edges) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GraphProto.edges)
}
inline ::TensorProto* GraphProto::release_edges() {
  
  ::TensorProto* temp = edges_;
  edges_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TensorProto* GraphProto::unsafe_arena_release_edges() {
  // @@protoc_insertion_point(field_release:GraphProto.edges)
  
  ::TensorProto* temp = edges_;
  edges_ = nullptr;
  return temp;
}
inline ::TensorProto* GraphProto::_internal_mutable_edges() {
  
  if (edges_ == nullptr) {
    auto* p = CreateMaybeMessage<::TensorProto>(GetArenaForAllocation());
    edges_ = p;
  }
  return edges_;
}
inline ::TensorProto* GraphProto::mutable_edges() {
  ::TensorProto* _msg = _internal_mutable_edges();
  // @@protoc_insertion_point(field_mutable:GraphProto.edges)
  return _msg;
}
inline void GraphProto::set_allocated_edges(::TensorProto* edges) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete edges_;
  }
  if (edges) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TensorProto>::GetOwningArena(edges);
    if (message_arena != submessage_arena) {
      edges = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edges, submessage_arena);
    }
    
  } else {
    
  }
  edges_ = edges;
  // @@protoc_insertion_point(field_set_allocated:GraphProto.edges)
}

// .TensorProto edge_links = 3;
inline bool GraphProto::_internal_has_edge_links() const {
  return this != internal_default_instance() && edge_links_ != nullptr;
}
inline bool GraphProto::has_edge_links() const {
  return _internal_has_edge_links();
}
inline void GraphProto::clear_edge_links() {
  if (GetArenaForAllocation() == nullptr && edge_links_ != nullptr) {
    delete edge_links_;
  }
  edge_links_ = nullptr;
}
inline const ::TensorProto& GraphProto::_internal_edge_links() const {
  const ::TensorProto* p = edge_links_;
  return p != nullptr ? *p : reinterpret_cast<const ::TensorProto&>(
      ::_TensorProto_default_instance_);
}
inline const ::TensorProto& GraphProto::edge_links() const {
  // @@protoc_insertion_point(field_get:GraphProto.edge_links)
  return _internal_edge_links();
}
inline void GraphProto::unsafe_arena_set_allocated_edge_links(
    ::TensorProto* edge_links) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(edge_links_);
  }
  edge_links_ = edge_links;
  if (edge_links) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GraphProto.edge_links)
}
inline ::TensorProto* GraphProto::release_edge_links() {
  
  ::TensorProto* temp = edge_links_;
  edge_links_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TensorProto* GraphProto::unsafe_arena_release_edge_links() {
  // @@protoc_insertion_point(field_release:GraphProto.edge_links)
  
  ::TensorProto* temp = edge_links_;
  edge_links_ = nullptr;
  return temp;
}
inline ::TensorProto* GraphProto::_internal_mutable_edge_links() {
  
  if (edge_links_ == nullptr) {
    auto* p = CreateMaybeMessage<::TensorProto>(GetArenaForAllocation());
    edge_links_ = p;
  }
  return edge_links_;
}
inline ::TensorProto* GraphProto::mutable_edge_links() {
  ::TensorProto* _msg = _internal_mutable_edge_links();
  // @@protoc_insertion_point(field_mutable:GraphProto.edge_links)
  return _msg;
}
inline void GraphProto::set_allocated_edge_links(::TensorProto* edge_links) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete edge_links_;
  }
  if (edge_links) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TensorProto>::GetOwningArena(edge_links);
    if (message_arena != submessage_arena) {
      edge_links = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edge_links, submessage_arena);
    }
    
  } else {
    
  }
  edge_links_ = edge_links;
  // @@protoc_insertion_point(field_set_allocated:GraphProto.edge_links)
}

// -------------------------------------------------------------------

// ImageProto

// .CompressionTypeProto compression_type = 1;
inline void ImageProto::clear_compression_type() {
  compression_type_ = 0;
}
inline ::CompressionTypeProto ImageProto::_internal_compression_type() const {
  return static_cast< ::CompressionTypeProto >(compression_type_);
}
inline ::CompressionTypeProto ImageProto::compression_type() const {
  // @@protoc_insertion_point(field_get:ImageProto.compression_type)
  return _internal_compression_type();
}
inline void ImageProto::_internal_set_compression_type(::CompressionTypeProto value) {
  
  compression_type_ = value;
}
inline void ImageProto::set_compression_type(::CompressionTypeProto value) {
  _internal_set_compression_type(value);
  // @@protoc_insertion_point(field_set:ImageProto.compression_type)
}

// bytes data = 2;
inline void ImageProto::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& ImageProto::data() const {
  // @@protoc_insertion_point(field_get:ImageProto.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageProto::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ImageProto.data)
}
inline std::string* ImageProto::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:ImageProto.data)
  return _s;
}
inline const std::string& ImageProto::_internal_data() const {
  return data_.Get();
}
inline void ImageProto::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImageProto::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImageProto::release_data() {
  // @@protoc_insertion_point(field_release:ImageProto.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImageProto::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImageProto.data)
}

// string dtype = 3;
inline void ImageProto::clear_dtype() {
  dtype_.ClearToEmpty();
}
inline const std::string& ImageProto::dtype() const {
  // @@protoc_insertion_point(field_get:ImageProto.dtype)
  return _internal_dtype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageProto::set_dtype(ArgT0&& arg0, ArgT... args) {
 
 dtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ImageProto.dtype)
}
inline std::string* ImageProto::mutable_dtype() {
  std::string* _s = _internal_mutable_dtype();
  // @@protoc_insertion_point(field_mutable:ImageProto.dtype)
  return _s;
}
inline const std::string& ImageProto::_internal_dtype() const {
  return dtype_.Get();
}
inline void ImageProto::_internal_set_dtype(const std::string& value) {
  
  dtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImageProto::_internal_mutable_dtype() {
  
  return dtype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImageProto::release_dtype() {
  // @@protoc_insertion_point(field_release:ImageProto.dtype)
  return dtype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImageProto::set_allocated_dtype(std::string* dtype) {
  if (dtype != nullptr) {
    
  } else {
    
  }
  dtype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dtype,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (dtype_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    dtype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImageProto.dtype)
}

// repeated int32 shape = 4;
inline int ImageProto::_internal_shape_size() const {
  return shape_.size();
}
inline int ImageProto::shape_size() const {
  return _internal_shape_size();
}
inline void ImageProto::clear_shape() {
  shape_.Clear();
}
inline int32_t ImageProto::_internal_shape(int index) const {
  return shape_.Get(index);
}
inline int32_t ImageProto::shape(int index) const {
  // @@protoc_insertion_point(field_get:ImageProto.shape)
  return _internal_shape(index);
}
inline void ImageProto::set_shape(int index, int32_t value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:ImageProto.shape)
}
inline void ImageProto::_internal_add_shape(int32_t value) {
  shape_.Add(value);
}
inline void ImageProto::add_shape(int32_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:ImageProto.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ImageProto::_internal_shape() const {
  return shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ImageProto::shape() const {
  // @@protoc_insertion_point(field_list:ImageProto.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ImageProto::_internal_mutable_shape() {
  return &shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ImageProto::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:ImageProto.shape)
  return _internal_mutable_shape();
}

// repeated int32 transpose_axes = 5;
inline int ImageProto::_internal_transpose_axes_size() const {
  return transpose_axes_.size();
}
inline int ImageProto::transpose_axes_size() const {
  return _internal_transpose_axes_size();
}
inline void ImageProto::clear_transpose_axes() {
  transpose_axes_.Clear();
}
inline int32_t ImageProto::_internal_transpose_axes(int index) const {
  return transpose_axes_.Get(index);
}
inline int32_t ImageProto::transpose_axes(int index) const {
  // @@protoc_insertion_point(field_get:ImageProto.transpose_axes)
  return _internal_transpose_axes(index);
}
inline void ImageProto::set_transpose_axes(int index, int32_t value) {
  transpose_axes_.Set(index, value);
  // @@protoc_insertion_point(field_set:ImageProto.transpose_axes)
}
inline void ImageProto::_internal_add_transpose_axes(int32_t value) {
  transpose_axes_.Add(value);
}
inline void ImageProto::add_transpose_axes(int32_t value) {
  _internal_add_transpose_axes(value);
  // @@protoc_insertion_point(field_add:ImageProto.transpose_axes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ImageProto::_internal_transpose_axes() const {
  return transpose_axes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ImageProto::transpose_axes() const {
  // @@protoc_insertion_point(field_list:ImageProto.transpose_axes)
  return _internal_transpose_axes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ImageProto::_internal_mutable_transpose_axes() {
  return &transpose_axes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ImageProto::mutable_transpose_axes() {
  // @@protoc_insertion_point(field_mutable_list:ImageProto.transpose_axes)
  return _internal_mutable_transpose_axes();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// InstanceProto

// .InstanceTypeProto type = 1;
inline void InstanceProto::clear_type() {
  type_ = 0;
}
inline ::InstanceTypeProto InstanceProto::_internal_type() const {
  return static_cast< ::InstanceTypeProto >(type_);
}
inline ::InstanceTypeProto InstanceProto::type() const {
  // @@protoc_insertion_point(field_get:InstanceProto.type)
  return _internal_type();
}
inline void InstanceProto::_internal_set_type(::InstanceTypeProto value) {
  
  type_ = value;
}
inline void InstanceProto::set_type(::InstanceTypeProto value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:InstanceProto.type)
}

// bytes raw_data = 2;
inline void InstanceProto::clear_raw_data() {
  raw_data_.ClearToEmpty();
}
inline const std::string& InstanceProto::raw_data() const {
  // @@protoc_insertion_point(field_get:InstanceProto.raw_data)
  return _internal_raw_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceProto::set_raw_data(ArgT0&& arg0, ArgT... args) {
 
 raw_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InstanceProto.raw_data)
}
inline std::string* InstanceProto::mutable_raw_data() {
  std::string* _s = _internal_mutable_raw_data();
  // @@protoc_insertion_point(field_mutable:InstanceProto.raw_data)
  return _s;
}
inline const std::string& InstanceProto::_internal_raw_data() const {
  return raw_data_.Get();
}
inline void InstanceProto::_internal_set_raw_data(const std::string& value) {
  
  raw_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InstanceProto::_internal_mutable_raw_data() {
  
  return raw_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InstanceProto::release_raw_data() {
  // @@protoc_insertion_point(field_release:InstanceProto.raw_data)
  return raw_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InstanceProto::set_allocated_raw_data(std::string* raw_data) {
  if (raw_data != nullptr) {
    
  } else {
    
  }
  raw_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), raw_data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (raw_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    raw_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InstanceProto.raw_data)
}

// .TensorProto tensor = 3;
inline bool InstanceProto::_internal_has_tensor() const {
  return this != internal_default_instance() && tensor_ != nullptr;
}
inline bool InstanceProto::has_tensor() const {
  return _internal_has_tensor();
}
inline void InstanceProto::clear_tensor() {
  if (GetArenaForAllocation() == nullptr && tensor_ != nullptr) {
    delete tensor_;
  }
  tensor_ = nullptr;
}
inline const ::TensorProto& InstanceProto::_internal_tensor() const {
  const ::TensorProto* p = tensor_;
  return p != nullptr ? *p : reinterpret_cast<const ::TensorProto&>(
      ::_TensorProto_default_instance_);
}
inline const ::TensorProto& InstanceProto::tensor() const {
  // @@protoc_insertion_point(field_get:InstanceProto.tensor)
  return _internal_tensor();
}
inline void InstanceProto::unsafe_arena_set_allocated_tensor(
    ::TensorProto* tensor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tensor_);
  }
  tensor_ = tensor;
  if (tensor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InstanceProto.tensor)
}
inline ::TensorProto* InstanceProto::release_tensor() {
  
  ::TensorProto* temp = tensor_;
  tensor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TensorProto* InstanceProto::unsafe_arena_release_tensor() {
  // @@protoc_insertion_point(field_release:InstanceProto.tensor)
  
  ::TensorProto* temp = tensor_;
  tensor_ = nullptr;
  return temp;
}
inline ::TensorProto* InstanceProto::_internal_mutable_tensor() {
  
  if (tensor_ == nullptr) {
    auto* p = CreateMaybeMessage<::TensorProto>(GetArenaForAllocation());
    tensor_ = p;
  }
  return tensor_;
}
inline ::TensorProto* InstanceProto::mutable_tensor() {
  ::TensorProto* _msg = _internal_mutable_tensor();
  // @@protoc_insertion_point(field_mutable:InstanceProto.tensor)
  return _msg;
}
inline void InstanceProto::set_allocated_tensor(::TensorProto* tensor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tensor_;
  }
  if (tensor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::TensorProto>::GetOwningArena(tensor);
    if (message_arena != submessage_arena) {
      tensor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tensor, submessage_arena);
    }
    
  } else {
    
  }
  tensor_ = tensor;
  // @@protoc_insertion_point(field_set_allocated:InstanceProto.tensor)
}

// int64 discrete = 4;
inline void InstanceProto::clear_discrete() {
  discrete_ = int64_t{0};
}
inline int64_t InstanceProto::_internal_discrete() const {
  return discrete_;
}
inline int64_t InstanceProto::discrete() const {
  // @@protoc_insertion_point(field_get:InstanceProto.discrete)
  return _internal_discrete();
}
inline void InstanceProto::_internal_set_discrete(int64_t value) {
  
  discrete_ = value;
}
inline void InstanceProto::set_discrete(int64_t value) {
  _internal_set_discrete(value);
  // @@protoc_insertion_point(field_set:InstanceProto.discrete)
}

// string text = 5;
inline void InstanceProto::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& InstanceProto::text() const {
  // @@protoc_insertion_point(field_get:InstanceProto.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceProto::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InstanceProto.text)
}
inline std::string* InstanceProto::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:InstanceProto.text)
  return _s;
}
inline const std::string& InstanceProto::_internal_text() const {
  return text_.Get();
}
inline void InstanceProto::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InstanceProto::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InstanceProto::release_text() {
  // @@protoc_insertion_point(field_release:InstanceProto.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InstanceProto::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InstanceProto.text)
}

// map<string, .InstanceProto> dict = 6;
inline int InstanceProto::_internal_dict_size() const {
  return dict_.size();
}
inline int InstanceProto::dict_size() const {
  return _internal_dict_size();
}
inline void InstanceProto::clear_dict() {
  dict_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::InstanceProto >&
InstanceProto::_internal_dict() const {
  return dict_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::InstanceProto >&
InstanceProto::dict() const {
  // @@protoc_insertion_point(field_map:InstanceProto.dict)
  return _internal_dict();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::InstanceProto >*
InstanceProto::_internal_mutable_dict() {
  return dict_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::InstanceProto >*
InstanceProto::mutable_dict() {
  // @@protoc_insertion_point(field_mutable_map:InstanceProto.dict)
  return _internal_mutable_dict();
}

// repeated .InstanceProto list = 7;
inline int InstanceProto::_internal_list_size() const {
  return list_.size();
}
inline int InstanceProto::list_size() const {
  return _internal_list_size();
}
inline void InstanceProto::clear_list() {
  list_.Clear();
}
inline ::InstanceProto* InstanceProto::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:InstanceProto.list)
  return list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InstanceProto >*
InstanceProto::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:InstanceProto.list)
  return &list_;
}
inline const ::InstanceProto& InstanceProto::_internal_list(int index) const {
  return list_.Get(index);
}
inline const ::InstanceProto& InstanceProto::list(int index) const {
  // @@protoc_insertion_point(field_get:InstanceProto.list)
  return _internal_list(index);
}
inline ::InstanceProto* InstanceProto::_internal_add_list() {
  return list_.Add();
}
inline ::InstanceProto* InstanceProto::add_list() {
  ::InstanceProto* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:InstanceProto.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InstanceProto >&
InstanceProto::list() const {
  // @@protoc_insertion_point(field_list:InstanceProto.list)
  return list_;
}

// .GraphProto graph = 8;
inline bool InstanceProto::_internal_has_graph() const {
  return this != internal_default_instance() && graph_ != nullptr;
}
inline bool InstanceProto::has_graph() const {
  return _internal_has_graph();
}
inline void InstanceProto::clear_graph() {
  if (GetArenaForAllocation() == nullptr && graph_ != nullptr) {
    delete graph_;
  }
  graph_ = nullptr;
}
inline const ::GraphProto& InstanceProto::_internal_graph() const {
  const ::GraphProto* p = graph_;
  return p != nullptr ? *p : reinterpret_cast<const ::GraphProto&>(
      ::_GraphProto_default_instance_);
}
inline const ::GraphProto& InstanceProto::graph() const {
  // @@protoc_insertion_point(field_get:InstanceProto.graph)
  return _internal_graph();
}
inline void InstanceProto::unsafe_arena_set_allocated_graph(
    ::GraphProto* graph) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(graph_);
  }
  graph_ = graph;
  if (graph) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InstanceProto.graph)
}
inline ::GraphProto* InstanceProto::release_graph() {
  
  ::GraphProto* temp = graph_;
  graph_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GraphProto* InstanceProto::unsafe_arena_release_graph() {
  // @@protoc_insertion_point(field_release:InstanceProto.graph)
  
  ::GraphProto* temp = graph_;
  graph_ = nullptr;
  return temp;
}
inline ::GraphProto* InstanceProto::_internal_mutable_graph() {
  
  if (graph_ == nullptr) {
    auto* p = CreateMaybeMessage<::GraphProto>(GetArenaForAllocation());
    graph_ = p;
  }
  return graph_;
}
inline ::GraphProto* InstanceProto::mutable_graph() {
  ::GraphProto* _msg = _internal_mutable_graph();
  // @@protoc_insertion_point(field_mutable:InstanceProto.graph)
  return _msg;
}
inline void InstanceProto::set_allocated_graph(::GraphProto* graph) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete graph_;
  }
  if (graph) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::GraphProto>::GetOwningArena(graph);
    if (message_arena != submessage_arena) {
      graph = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, graph, submessage_arena);
    }
    
  } else {
    
  }
  graph_ = graph;
  // @@protoc_insertion_point(field_set_allocated:InstanceProto.graph)
}

// .ImageProto image = 9;
inline bool InstanceProto::_internal_has_image() const {
  return this != internal_default_instance() && image_ != nullptr;
}
inline bool InstanceProto::has_image() const {
  return _internal_has_image();
}
inline void InstanceProto::clear_image() {
  if (GetArenaForAllocation() == nullptr && image_ != nullptr) {
    delete image_;
  }
  image_ = nullptr;
}
inline const ::ImageProto& InstanceProto::_internal_image() const {
  const ::ImageProto* p = image_;
  return p != nullptr ? *p : reinterpret_cast<const ::ImageProto&>(
      ::_ImageProto_default_instance_);
}
inline const ::ImageProto& InstanceProto::image() const {
  // @@protoc_insertion_point(field_get:InstanceProto.image)
  return _internal_image();
}
inline void InstanceProto::unsafe_arena_set_allocated_image(
    ::ImageProto* image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_);
  }
  image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InstanceProto.image)
}
inline ::ImageProto* InstanceProto::release_image() {
  
  ::ImageProto* temp = image_;
  image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ImageProto* InstanceProto::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:InstanceProto.image)
  
  ::ImageProto* temp = image_;
  image_ = nullptr;
  return temp;
}
inline ::ImageProto* InstanceProto::_internal_mutable_image() {
  
  if (image_ == nullptr) {
    auto* p = CreateMaybeMessage<::ImageProto>(GetArenaForAllocation());
    image_ = p;
  }
  return image_;
}
inline ::ImageProto* InstanceProto::mutable_image() {
  ::ImageProto* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:InstanceProto.image)
  return _msg;
}
inline void InstanceProto::set_allocated_image(::ImageProto* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete image_;
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::ImageProto>::GetOwningArena(image);
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:InstanceProto.image)
}

// double float = 10;
inline void InstanceProto::clear_float_() {
  float__ = 0;
}
inline double InstanceProto::_internal_float_() const {
  return float__;
}
inline double InstanceProto::float_() const {
  // @@protoc_insertion_point(field_get:InstanceProto.float)
  return _internal_float_();
}
inline void InstanceProto::_internal_set_float_(double value) {
  
  float__ = value;
}
inline void InstanceProto::set_float_(double value) {
  _internal_set_float_(value);
  // @@protoc_insertion_point(field_set:InstanceProto.float)
}

// bool boolean = 11;
inline void InstanceProto::clear_boolean() {
  boolean_ = false;
}
inline bool InstanceProto::_internal_boolean() const {
  return boolean_;
}
inline bool InstanceProto::boolean() const {
  // @@protoc_insertion_point(field_get:InstanceProto.boolean)
  return _internal_boolean();
}
inline void InstanceProto::_internal_set_boolean(bool value) {
  
  boolean_ = value;
}
inline void InstanceProto::set_boolean(bool value) {
  _internal_set_boolean(value);
  // @@protoc_insertion_point(field_set:InstanceProto.boolean)
}

// string json = 12;
inline void InstanceProto::clear_json() {
  json_.ClearToEmpty();
}
inline const std::string& InstanceProto::json() const {
  // @@protoc_insertion_point(field_get:InstanceProto.json)
  return _internal_json();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceProto::set_json(ArgT0&& arg0, ArgT... args) {
 
 json_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InstanceProto.json)
}
inline std::string* InstanceProto::mutable_json() {
  std::string* _s = _internal_mutable_json();
  // @@protoc_insertion_point(field_mutable:InstanceProto.json)
  return _s;
}
inline const std::string& InstanceProto::_internal_json() const {
  return json_.Get();
}
inline void InstanceProto::_internal_set_json(const std::string& value) {
  
  json_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InstanceProto::_internal_mutable_json() {
  
  return json_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InstanceProto::release_json() {
  // @@protoc_insertion_point(field_release:InstanceProto.json)
  return json_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InstanceProto::set_allocated_json(std::string* json) {
  if (json != nullptr) {
    
  } else {
    
  }
  json_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), json,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (json_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    json_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InstanceProto.json)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::CompressionTypeProto> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CompressionTypeProto>() {
  return ::CompressionTypeProto_descriptor();
}
template <> struct is_proto_enum< ::InstanceTypeProto> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::InstanceTypeProto>() {
  return ::InstanceTypeProto_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_space_2eproto
