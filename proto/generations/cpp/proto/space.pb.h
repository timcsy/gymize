// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: space.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_space_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_space_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_space_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_space_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_space_2eproto;
class BoolTensor;
struct BoolTensorDefaultTypeInternal;
extern BoolTensorDefaultTypeInternal _BoolTensor_default_instance_;
class Data;
struct DataDefaultTypeInternal;
extern DataDefaultTypeInternal _Data_default_instance_;
class Data_DictEntry_DoNotUse;
struct Data_DictEntry_DoNotUseDefaultTypeInternal;
extern Data_DictEntry_DoNotUseDefaultTypeInternal _Data_DictEntry_DoNotUse_default_instance_;
class Data_ListEntry_DoNotUse;
struct Data_ListEntry_DoNotUseDefaultTypeInternal;
extern Data_ListEntry_DoNotUseDefaultTypeInternal _Data_ListEntry_DoNotUse_default_instance_;
class FloatTensor;
struct FloatTensorDefaultTypeInternal;
extern FloatTensorDefaultTypeInternal _FloatTensor_default_instance_;
class Graph;
struct GraphDefaultTypeInternal;
extern GraphDefaultTypeInternal _Graph_default_instance_;
class GraphSpace;
struct GraphSpaceDefaultTypeInternal;
extern GraphSpaceDefaultTypeInternal _GraphSpace_default_instance_;
class Image;
struct ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class IntTensor;
struct IntTensorDefaultTypeInternal;
extern IntTensorDefaultTypeInternal _IntTensor_default_instance_;
class Space;
struct SpaceDefaultTypeInternal;
extern SpaceDefaultTypeInternal _Space_default_instance_;
class Space_DictSpaceEntry_DoNotUse;
struct Space_DictSpaceEntry_DoNotUseDefaultTypeInternal;
extern Space_DictSpaceEntry_DoNotUseDefaultTypeInternal _Space_DictSpaceEntry_DoNotUse_default_instance_;
class Space_ListSpaceEntry_DoNotUse;
struct Space_ListSpaceEntry_DoNotUseDefaultTypeInternal;
extern Space_ListSpaceEntry_DoNotUseDefaultTypeInternal _Space_ListSpaceEntry_DoNotUse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::BoolTensor* Arena::CreateMaybeMessage<::BoolTensor>(Arena*);
template<> ::Data* Arena::CreateMaybeMessage<::Data>(Arena*);
template<> ::Data_DictEntry_DoNotUse* Arena::CreateMaybeMessage<::Data_DictEntry_DoNotUse>(Arena*);
template<> ::Data_ListEntry_DoNotUse* Arena::CreateMaybeMessage<::Data_ListEntry_DoNotUse>(Arena*);
template<> ::FloatTensor* Arena::CreateMaybeMessage<::FloatTensor>(Arena*);
template<> ::Graph* Arena::CreateMaybeMessage<::Graph>(Arena*);
template<> ::GraphSpace* Arena::CreateMaybeMessage<::GraphSpace>(Arena*);
template<> ::Image* Arena::CreateMaybeMessage<::Image>(Arena*);
template<> ::IntTensor* Arena::CreateMaybeMessage<::IntTensor>(Arena*);
template<> ::Space* Arena::CreateMaybeMessage<::Space>(Arena*);
template<> ::Space_DictSpaceEntry_DoNotUse* Arena::CreateMaybeMessage<::Space_DictSpaceEntry_DoNotUse>(Arena*);
template<> ::Space_ListSpaceEntry_DoNotUse* Arena::CreateMaybeMessage<::Space_ListSpaceEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum CompressionType : int {
  COMPRESSION_TYPE_UNSPECIFIED = 0,
  COMPRESSION_TYPE_NONE = 1,
  COMPRESSION_TYPE_PNG = 2,
  COMPRESSION_TYPE_JPG = 3,
  CompressionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CompressionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CompressionType_IsValid(int value);
constexpr CompressionType CompressionType_MIN = COMPRESSION_TYPE_UNSPECIFIED;
constexpr CompressionType CompressionType_MAX = COMPRESSION_TYPE_JPG;
constexpr int CompressionType_ARRAYSIZE = CompressionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompressionType_descriptor();
template<typename T>
inline const std::string& CompressionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompressionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompressionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CompressionType_descriptor(), enum_t_value);
}
inline bool CompressionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CompressionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CompressionType>(
    CompressionType_descriptor(), name, value);
}
enum SpaceType : int {
  SPACE_TYPE_UNSPECIFIED = 0,
  SPACE_TYPE_BOX = 1,
  SPACE_TYPE_DISCRETE = 2,
  SPACE_TYPE_MULTI_BINARY = 3,
  SPACE_TYPE_MULTI_DISCRETE = 4,
  SPACE_TYPE_TEXT = 5,
  SPACE_TYPE_DICT = 6,
  SPACE_TYPE_TUPLE = 7,
  SPACE_TYPE_SEQUENCE = 8,
  SPACE_TYPE_GRAPH = 9,
  SPACE_TYPE_IMAGE = 10,
  SpaceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SpaceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SpaceType_IsValid(int value);
constexpr SpaceType SpaceType_MIN = SPACE_TYPE_UNSPECIFIED;
constexpr SpaceType SpaceType_MAX = SPACE_TYPE_IMAGE;
constexpr int SpaceType_ARRAYSIZE = SpaceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpaceType_descriptor();
template<typename T>
inline const std::string& SpaceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpaceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpaceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpaceType_descriptor(), enum_t_value);
}
inline bool SpaceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SpaceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpaceType>(
    SpaceType_descriptor(), name, value);
}
enum DataType : int {
  DATA_TYPE_UNSPECIFIED = 0,
  DATA_TYPE_FLOAT = 1,
  DATA_TYPE_INT = 2,
  DATA_TYPE_BOOLEAN = 3,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataType_IsValid(int value);
constexpr DataType DataType_MIN = DATA_TYPE_UNSPECIFIED;
constexpr DataType DataType_MAX = DATA_TYPE_BOOLEAN;
constexpr int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataType_descriptor();
template<typename T>
inline const std::string& DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataType_descriptor(), enum_t_value);
}
inline bool DataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
// ===================================================================

class FloatTensor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FloatTensor) */ {
 public:
  inline FloatTensor() : FloatTensor(nullptr) {}
  ~FloatTensor() override;
  explicit constexpr FloatTensor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FloatTensor(const FloatTensor& from);
  FloatTensor(FloatTensor&& from) noexcept
    : FloatTensor() {
    *this = ::std::move(from);
  }

  inline FloatTensor& operator=(const FloatTensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatTensor& operator=(FloatTensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatTensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const FloatTensor* internal_default_instance() {
    return reinterpret_cast<const FloatTensor*>(
               &_FloatTensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FloatTensor& a, FloatTensor& b) {
    a.Swap(&b);
  }
  inline void Swap(FloatTensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatTensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FloatTensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FloatTensor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FloatTensor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FloatTensor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatTensor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FloatTensor";
  }
  protected:
  explicit FloatTensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 1,
    kArrayFieldNumber = 2,
  };
  // repeated int32 shape = 1;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int32_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_shape() const;
  void _internal_add_shape(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_shape();
  public:
  int32_t shape(int index) const;
  void set_shape(int index, int32_t value);
  void add_shape(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_shape();

  // repeated float array = 2;
  int array_size() const;
  private:
  int _internal_array_size() const;
  public:
  void clear_array();
  private:
  float _internal_array(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_array() const;
  void _internal_add_array(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_array();
  public:
  float array(int index) const;
  void set_array(int index, float value);
  void add_array(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      array() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_array();

  // @@protoc_insertion_point(class_scope:FloatTensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > shape_;
  mutable std::atomic<int> _shape_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > array_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_space_2eproto;
};
// -------------------------------------------------------------------

class IntTensor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntTensor) */ {
 public:
  inline IntTensor() : IntTensor(nullptr) {}
  ~IntTensor() override;
  explicit constexpr IntTensor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntTensor(const IntTensor& from);
  IntTensor(IntTensor&& from) noexcept
    : IntTensor() {
    *this = ::std::move(from);
  }

  inline IntTensor& operator=(const IntTensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntTensor& operator=(IntTensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntTensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntTensor* internal_default_instance() {
    return reinterpret_cast<const IntTensor*>(
               &_IntTensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(IntTensor& a, IntTensor& b) {
    a.Swap(&b);
  }
  inline void Swap(IntTensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntTensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntTensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntTensor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntTensor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IntTensor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntTensor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntTensor";
  }
  protected:
  explicit IntTensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 1,
    kArrayFieldNumber = 2,
  };
  // repeated int32 shape = 1;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int32_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_shape() const;
  void _internal_add_shape(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_shape();
  public:
  int32_t shape(int index) const;
  void set_shape(int index, int32_t value);
  void add_shape(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_shape();

  // repeated int32 array = 2;
  int array_size() const;
  private:
  int _internal_array_size() const;
  public:
  void clear_array();
  private:
  int32_t _internal_array(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_array() const;
  void _internal_add_array(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_array();
  public:
  int32_t array(int index) const;
  void set_array(int index, int32_t value);
  void add_array(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      array() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_array();

  // @@protoc_insertion_point(class_scope:IntTensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > shape_;
  mutable std::atomic<int> _shape_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > array_;
  mutable std::atomic<int> _array_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_space_2eproto;
};
// -------------------------------------------------------------------

class BoolTensor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BoolTensor) */ {
 public:
  inline BoolTensor() : BoolTensor(nullptr) {}
  ~BoolTensor() override;
  explicit constexpr BoolTensor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoolTensor(const BoolTensor& from);
  BoolTensor(BoolTensor&& from) noexcept
    : BoolTensor() {
    *this = ::std::move(from);
  }

  inline BoolTensor& operator=(const BoolTensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolTensor& operator=(BoolTensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolTensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoolTensor* internal_default_instance() {
    return reinterpret_cast<const BoolTensor*>(
               &_BoolTensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BoolTensor& a, BoolTensor& b) {
    a.Swap(&b);
  }
  inline void Swap(BoolTensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolTensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolTensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoolTensor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoolTensor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BoolTensor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoolTensor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BoolTensor";
  }
  protected:
  explicit BoolTensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 1,
    kArrayFieldNumber = 2,
  };
  // repeated int32 shape = 1;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int32_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_shape() const;
  void _internal_add_shape(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_shape();
  public:
  int32_t shape(int index) const;
  void set_shape(int index, int32_t value);
  void add_shape(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_shape();

  // repeated bool array = 2;
  int array_size() const;
  private:
  int _internal_array_size() const;
  public:
  void clear_array();
  private:
  bool _internal_array(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_array() const;
  void _internal_add_array(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_array();
  public:
  bool array(int index) const;
  void set_array(int index, bool value);
  void add_array(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      array() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_array();

  // @@protoc_insertion_point(class_scope:BoolTensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > shape_;
  mutable std::atomic<int> _shape_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > array_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_space_2eproto;
};
// -------------------------------------------------------------------

class GraphSpace final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GraphSpace) */ {
 public:
  inline GraphSpace() : GraphSpace(nullptr) {}
  ~GraphSpace() override;
  explicit constexpr GraphSpace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GraphSpace(const GraphSpace& from);
  GraphSpace(GraphSpace&& from) noexcept
    : GraphSpace() {
    *this = ::std::move(from);
  }

  inline GraphSpace& operator=(const GraphSpace& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphSpace& operator=(GraphSpace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphSpace& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphSpace* internal_default_instance() {
    return reinterpret_cast<const GraphSpace*>(
               &_GraphSpace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GraphSpace& a, GraphSpace& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphSpace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphSpace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphSpace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraphSpace>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GraphSpace& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GraphSpace& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphSpace* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GraphSpace";
  }
  protected:
  explicit GraphSpace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeSpaceFieldNumber = 1,
    kEdgeSpaceFieldNumber = 2,
  };
  // .Space node_space = 1;
  bool has_node_space() const;
  private:
  bool _internal_has_node_space() const;
  public:
  void clear_node_space();
  const ::Space& node_space() const;
  PROTOBUF_NODISCARD ::Space* release_node_space();
  ::Space* mutable_node_space();
  void set_allocated_node_space(::Space* node_space);
  private:
  const ::Space& _internal_node_space() const;
  ::Space* _internal_mutable_node_space();
  public:
  void unsafe_arena_set_allocated_node_space(
      ::Space* node_space);
  ::Space* unsafe_arena_release_node_space();

  // .Space edge_space = 2;
  bool has_edge_space() const;
  private:
  bool _internal_has_edge_space() const;
  public:
  void clear_edge_space();
  const ::Space& edge_space() const;
  PROTOBUF_NODISCARD ::Space* release_edge_space();
  ::Space* mutable_edge_space();
  void set_allocated_edge_space(::Space* edge_space);
  private:
  const ::Space& _internal_edge_space() const;
  ::Space* _internal_mutable_edge_space();
  public:
  void unsafe_arena_set_allocated_edge_space(
      ::Space* edge_space);
  ::Space* unsafe_arena_release_edge_space();

  // @@protoc_insertion_point(class_scope:GraphSpace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Space* node_space_;
  ::Space* edge_space_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_space_2eproto;
};
// -------------------------------------------------------------------

class Graph final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Graph) */ {
 public:
  inline Graph() : Graph(nullptr) {}
  ~Graph() override;
  explicit constexpr Graph(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Graph(const Graph& from);
  Graph(Graph&& from) noexcept
    : Graph() {
    *this = ::std::move(from);
  }

  inline Graph& operator=(const Graph& from) {
    CopyFrom(from);
    return *this;
  }
  inline Graph& operator=(Graph&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Graph& default_instance() {
    return *internal_default_instance();
  }
  static inline const Graph* internal_default_instance() {
    return reinterpret_cast<const Graph*>(
               &_Graph_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Graph& a, Graph& b) {
    a.Swap(&b);
  }
  inline void Swap(Graph* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Graph* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Graph* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Graph>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Graph& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Graph& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Graph* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Graph";
  }
  protected:
  explicit Graph(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
    kEdgesFieldNumber = 2,
    kEdgeLinksFieldNumber = 3,
  };
  // .FloatTensor nodes = 1;
  bool has_nodes() const;
  private:
  bool _internal_has_nodes() const;
  public:
  void clear_nodes();
  const ::FloatTensor& nodes() const;
  PROTOBUF_NODISCARD ::FloatTensor* release_nodes();
  ::FloatTensor* mutable_nodes();
  void set_allocated_nodes(::FloatTensor* nodes);
  private:
  const ::FloatTensor& _internal_nodes() const;
  ::FloatTensor* _internal_mutable_nodes();
  public:
  void unsafe_arena_set_allocated_nodes(
      ::FloatTensor* nodes);
  ::FloatTensor* unsafe_arena_release_nodes();

  // .FloatTensor edges = 2;
  bool has_edges() const;
  private:
  bool _internal_has_edges() const;
  public:
  void clear_edges();
  const ::FloatTensor& edges() const;
  PROTOBUF_NODISCARD ::FloatTensor* release_edges();
  ::FloatTensor* mutable_edges();
  void set_allocated_edges(::FloatTensor* edges);
  private:
  const ::FloatTensor& _internal_edges() const;
  ::FloatTensor* _internal_mutable_edges();
  public:
  void unsafe_arena_set_allocated_edges(
      ::FloatTensor* edges);
  ::FloatTensor* unsafe_arena_release_edges();

  // .IntTensor edge_links = 3;
  bool has_edge_links() const;
  private:
  bool _internal_has_edge_links() const;
  public:
  void clear_edge_links();
  const ::IntTensor& edge_links() const;
  PROTOBUF_NODISCARD ::IntTensor* release_edge_links();
  ::IntTensor* mutable_edge_links();
  void set_allocated_edge_links(::IntTensor* edge_links);
  private:
  const ::IntTensor& _internal_edge_links() const;
  ::IntTensor* _internal_mutable_edge_links();
  public:
  void unsafe_arena_set_allocated_edge_links(
      ::IntTensor* edge_links);
  ::IntTensor* unsafe_arena_release_edge_links();

  // @@protoc_insertion_point(class_scope:Graph)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::FloatTensor* nodes_;
  ::FloatTensor* edges_;
  ::IntTensor* edge_links_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_space_2eproto;
};
// -------------------------------------------------------------------

class Image final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Image) */ {
 public:
  inline Image() : Image(nullptr) {}
  ~Image() override;
  explicit constexpr Image(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Image(const Image& from);
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Image& default_instance() {
    return *internal_default_instance();
  }
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }
  inline void Swap(Image* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Image& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Image& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Image";
  }
  protected:
  explicit Image(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 3,
    kDimensionMappingFieldNumber = 4,
    kDataFieldNumber = 2,
    kCompressionTypeFieldNumber = 1,
  };
  // repeated int32 shape = 3;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int32_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_shape() const;
  void _internal_add_shape(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_shape();
  public:
  int32_t shape(int index) const;
  void set_shape(int index, int32_t value);
  void add_shape(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_shape();

  // repeated int32 dimension_mapping = 4;
  int dimension_mapping_size() const;
  private:
  int _internal_dimension_mapping_size() const;
  public:
  void clear_dimension_mapping();
  private:
  int32_t _internal_dimension_mapping(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_dimension_mapping() const;
  void _internal_add_dimension_mapping(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_dimension_mapping();
  public:
  int32_t dimension_mapping(int index) const;
  void set_dimension_mapping(int index, int32_t value);
  void add_dimension_mapping(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      dimension_mapping() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_dimension_mapping();

  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .CompressionType compression_type = 1;
  void clear_compression_type();
  ::CompressionType compression_type() const;
  void set_compression_type(::CompressionType value);
  private:
  ::CompressionType _internal_compression_type() const;
  void _internal_set_compression_type(::CompressionType value);
  public:

  // @@protoc_insertion_point(class_scope:Image)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > shape_;
  mutable std::atomic<int> _shape_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > dimension_mapping_;
  mutable std::atomic<int> _dimension_mapping_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  int compression_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_space_2eproto;
};
// -------------------------------------------------------------------

class Space_DictSpaceEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Space_DictSpaceEntry_DoNotUse, 
    std::string, ::Space,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Space_DictSpaceEntry_DoNotUse, 
    std::string, ::Space,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Space_DictSpaceEntry_DoNotUse();
  explicit constexpr Space_DictSpaceEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Space_DictSpaceEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Space_DictSpaceEntry_DoNotUse& other);
  static const Space_DictSpaceEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Space_DictSpaceEntry_DoNotUse*>(&_Space_DictSpaceEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Space.DictSpaceEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Space_ListSpaceEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Space_ListSpaceEntry_DoNotUse, 
    int32_t, ::Space,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Space_ListSpaceEntry_DoNotUse, 
    int32_t, ::Space,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Space_ListSpaceEntry_DoNotUse();
  explicit constexpr Space_ListSpaceEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Space_ListSpaceEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Space_ListSpaceEntry_DoNotUse& other);
  static const Space_ListSpaceEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Space_ListSpaceEntry_DoNotUse*>(&_Space_ListSpaceEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Space final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Space) */ {
 public:
  inline Space() : Space(nullptr) {}
  ~Space() override;
  explicit constexpr Space(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Space(const Space& from);
  Space(Space&& from) noexcept
    : Space() {
    *this = ::std::move(from);
  }

  inline Space& operator=(const Space& from) {
    CopyFrom(from);
    return *this;
  }
  inline Space& operator=(Space&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Space& default_instance() {
    return *internal_default_instance();
  }
  static inline const Space* internal_default_instance() {
    return reinterpret_cast<const Space*>(
               &_Space_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Space& a, Space& b) {
    a.Swap(&b);
  }
  inline void Swap(Space* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Space* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Space* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Space>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Space& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Space& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Space* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Space";
  }
  protected:
  explicit Space(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 2,
    kLowFieldNumber = 4,
    kHighFieldNumber = 5,
    kNvecFieldNumber = 8,
    kCharsetFieldNumber = 9,
    kDictSpaceFieldNumber = 10,
    kListSpaceFieldNumber = 11,
    kGraphSpaceFieldNumber = 12,
    kSpaceTypeFieldNumber = 1,
    kDataTypeFieldNumber = 3,
    kMinFieldNumber = 6,
    kMaxFieldNumber = 7,
  };
  // repeated int32 shape = 2;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  int32_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_shape() const;
  void _internal_add_shape(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_shape();
  public:
  int32_t shape(int index) const;
  void set_shape(int index, int32_t value);
  void add_shape(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_shape();

  // repeated float low = 4;
  int low_size() const;
  private:
  int _internal_low_size() const;
  public:
  void clear_low();
  private:
  float _internal_low(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_low() const;
  void _internal_add_low(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_low();
  public:
  float low(int index) const;
  void set_low(int index, float value);
  void add_low(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      low() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_low();

  // repeated float high = 5;
  int high_size() const;
  private:
  int _internal_high_size() const;
  public:
  void clear_high();
  private:
  float _internal_high(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_high() const;
  void _internal_add_high(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_high();
  public:
  float high(int index) const;
  void set_high(int index, float value);
  void add_high(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      high() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_high();

  // repeated int32 nvec = 8;
  int nvec_size() const;
  private:
  int _internal_nvec_size() const;
  public:
  void clear_nvec();
  private:
  int32_t _internal_nvec(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_nvec() const;
  void _internal_add_nvec(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_nvec();
  public:
  int32_t nvec(int index) const;
  void set_nvec(int index, int32_t value);
  void add_nvec(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      nvec() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_nvec();

  // repeated string charset = 9;
  int charset_size() const;
  private:
  int _internal_charset_size() const;
  public:
  void clear_charset();
  const std::string& charset(int index) const;
  std::string* mutable_charset(int index);
  void set_charset(int index, const std::string& value);
  void set_charset(int index, std::string&& value);
  void set_charset(int index, const char* value);
  void set_charset(int index, const char* value, size_t size);
  std::string* add_charset();
  void add_charset(const std::string& value);
  void add_charset(std::string&& value);
  void add_charset(const char* value);
  void add_charset(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& charset() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_charset();
  private:
  const std::string& _internal_charset(int index) const;
  std::string* _internal_add_charset();
  public:

  // map<string, .Space> dict_space = 10;
  int dict_space_size() const;
  private:
  int _internal_dict_space_size() const;
  public:
  void clear_dict_space();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Space >&
      _internal_dict_space() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Space >*
      _internal_mutable_dict_space();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Space >&
      dict_space() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Space >*
      mutable_dict_space();

  // map<int32, .Space> list_space = 11;
  int list_space_size() const;
  private:
  int _internal_list_space_size() const;
  public:
  void clear_list_space();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::Space >&
      _internal_list_space() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::Space >*
      _internal_mutable_list_space();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::Space >&
      list_space() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::Space >*
      mutable_list_space();

  // .GraphSpace graph_space = 12;
  bool has_graph_space() const;
  private:
  bool _internal_has_graph_space() const;
  public:
  void clear_graph_space();
  const ::GraphSpace& graph_space() const;
  PROTOBUF_NODISCARD ::GraphSpace* release_graph_space();
  ::GraphSpace* mutable_graph_space();
  void set_allocated_graph_space(::GraphSpace* graph_space);
  private:
  const ::GraphSpace& _internal_graph_space() const;
  ::GraphSpace* _internal_mutable_graph_space();
  public:
  void unsafe_arena_set_allocated_graph_space(
      ::GraphSpace* graph_space);
  ::GraphSpace* unsafe_arena_release_graph_space();

  // .SpaceType space_type = 1;
  void clear_space_type();
  ::SpaceType space_type() const;
  void set_space_type(::SpaceType value);
  private:
  ::SpaceType _internal_space_type() const;
  void _internal_set_space_type(::SpaceType value);
  public:

  // .DataType data_type = 3;
  void clear_data_type();
  ::DataType data_type() const;
  void set_data_type(::DataType value);
  private:
  ::DataType _internal_data_type() const;
  void _internal_set_data_type(::DataType value);
  public:

  // int32 min = 6;
  void clear_min();
  int32_t min() const;
  void set_min(int32_t value);
  private:
  int32_t _internal_min() const;
  void _internal_set_min(int32_t value);
  public:

  // int32 max = 7;
  void clear_max();
  int32_t max() const;
  void set_max(int32_t value);
  private:
  int32_t _internal_max() const;
  void _internal_set_max(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Space)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > shape_;
  mutable std::atomic<int> _shape_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > low_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > high_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > nvec_;
  mutable std::atomic<int> _nvec_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> charset_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Space_DictSpaceEntry_DoNotUse,
      std::string, ::Space,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> dict_space_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Space_ListSpaceEntry_DoNotUse,
      int32_t, ::Space,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> list_space_;
  ::GraphSpace* graph_space_;
  int space_type_;
  int data_type_;
  int32_t min_;
  int32_t max_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_space_2eproto;
};
// -------------------------------------------------------------------

class Data_DictEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Data_DictEntry_DoNotUse, 
    std::string, ::Data,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Data_DictEntry_DoNotUse, 
    std::string, ::Data,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Data_DictEntry_DoNotUse();
  explicit constexpr Data_DictEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Data_DictEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Data_DictEntry_DoNotUse& other);
  static const Data_DictEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Data_DictEntry_DoNotUse*>(&_Data_DictEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Data.DictEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Data_ListEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Data_ListEntry_DoNotUse, 
    int32_t, ::Data,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Data_ListEntry_DoNotUse, 
    int32_t, ::Data,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Data_ListEntry_DoNotUse();
  explicit constexpr Data_ListEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Data_ListEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Data_ListEntry_DoNotUse& other);
  static const Data_ListEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Data_ListEntry_DoNotUse*>(&_Data_ListEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Data final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Data) */ {
 public:
  inline Data() : Data(nullptr) {}
  ~Data() override;
  explicit constexpr Data(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Data(const Data& from);
  Data(Data&& from) noexcept
    : Data() {
    *this = ::std::move(from);
  }

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline Data& operator=(Data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Data& default_instance() {
    return *internal_default_instance();
  }
  static inline const Data* internal_default_instance() {
    return reinterpret_cast<const Data*>(
               &_Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Data& a, Data& b) {
    a.Swap(&b);
  }
  inline void Swap(Data* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Data>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Data& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Data& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Data* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Data";
  }
  protected:
  explicit Data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDictFieldNumber = 7,
    kListFieldNumber = 8,
    kTextFieldNumber = 6,
    kBoxFieldNumber = 2,
    kMultiBinaryFieldNumber = 4,
    kMultiDiscreteFieldNumber = 5,
    kGraphFieldNumber = 9,
    kImageFieldNumber = 10,
    kSpaceTypeFieldNumber = 1,
    kDiscreteFieldNumber = 3,
  };
  // map<string, .Data> dict = 7;
  int dict_size() const;
  private:
  int _internal_dict_size() const;
  public:
  void clear_dict();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Data >&
      _internal_dict() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Data >*
      _internal_mutable_dict();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Data >&
      dict() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Data >*
      mutable_dict();

  // map<int32, .Data> list = 8;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::Data >&
      _internal_list() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::Data >*
      _internal_mutable_list();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::Data >&
      list() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::Data >*
      mutable_list();

  // string text = 6;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .FloatTensor box = 2;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::FloatTensor& box() const;
  PROTOBUF_NODISCARD ::FloatTensor* release_box();
  ::FloatTensor* mutable_box();
  void set_allocated_box(::FloatTensor* box);
  private:
  const ::FloatTensor& _internal_box() const;
  ::FloatTensor* _internal_mutable_box();
  public:
  void unsafe_arena_set_allocated_box(
      ::FloatTensor* box);
  ::FloatTensor* unsafe_arena_release_box();

  // .BoolTensor multi_binary = 4;
  bool has_multi_binary() const;
  private:
  bool _internal_has_multi_binary() const;
  public:
  void clear_multi_binary();
  const ::BoolTensor& multi_binary() const;
  PROTOBUF_NODISCARD ::BoolTensor* release_multi_binary();
  ::BoolTensor* mutable_multi_binary();
  void set_allocated_multi_binary(::BoolTensor* multi_binary);
  private:
  const ::BoolTensor& _internal_multi_binary() const;
  ::BoolTensor* _internal_mutable_multi_binary();
  public:
  void unsafe_arena_set_allocated_multi_binary(
      ::BoolTensor* multi_binary);
  ::BoolTensor* unsafe_arena_release_multi_binary();

  // .IntTensor multi_discrete = 5;
  bool has_multi_discrete() const;
  private:
  bool _internal_has_multi_discrete() const;
  public:
  void clear_multi_discrete();
  const ::IntTensor& multi_discrete() const;
  PROTOBUF_NODISCARD ::IntTensor* release_multi_discrete();
  ::IntTensor* mutable_multi_discrete();
  void set_allocated_multi_discrete(::IntTensor* multi_discrete);
  private:
  const ::IntTensor& _internal_multi_discrete() const;
  ::IntTensor* _internal_mutable_multi_discrete();
  public:
  void unsafe_arena_set_allocated_multi_discrete(
      ::IntTensor* multi_discrete);
  ::IntTensor* unsafe_arena_release_multi_discrete();

  // .Graph graph = 9;
  bool has_graph() const;
  private:
  bool _internal_has_graph() const;
  public:
  void clear_graph();
  const ::Graph& graph() const;
  PROTOBUF_NODISCARD ::Graph* release_graph();
  ::Graph* mutable_graph();
  void set_allocated_graph(::Graph* graph);
  private:
  const ::Graph& _internal_graph() const;
  ::Graph* _internal_mutable_graph();
  public:
  void unsafe_arena_set_allocated_graph(
      ::Graph* graph);
  ::Graph* unsafe_arena_release_graph();

  // .Image image = 10;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::Image& image() const;
  PROTOBUF_NODISCARD ::Image* release_image();
  ::Image* mutable_image();
  void set_allocated_image(::Image* image);
  private:
  const ::Image& _internal_image() const;
  ::Image* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::Image* image);
  ::Image* unsafe_arena_release_image();

  // .SpaceType space_type = 1;
  void clear_space_type();
  ::SpaceType space_type() const;
  void set_space_type(::SpaceType value);
  private:
  ::SpaceType _internal_space_type() const;
  void _internal_set_space_type(::SpaceType value);
  public:

  // int32 discrete = 3;
  void clear_discrete();
  int32_t discrete() const;
  void set_discrete(int32_t value);
  private:
  int32_t _internal_discrete() const;
  void _internal_set_discrete(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Data)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Data_DictEntry_DoNotUse,
      std::string, ::Data,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> dict_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Data_ListEntry_DoNotUse,
      int32_t, ::Data,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> list_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::FloatTensor* box_;
  ::BoolTensor* multi_binary_;
  ::IntTensor* multi_discrete_;
  ::Graph* graph_;
  ::Image* image_;
  int space_type_;
  int32_t discrete_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_space_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FloatTensor

// repeated int32 shape = 1;
inline int FloatTensor::_internal_shape_size() const {
  return shape_.size();
}
inline int FloatTensor::shape_size() const {
  return _internal_shape_size();
}
inline void FloatTensor::clear_shape() {
  shape_.Clear();
}
inline int32_t FloatTensor::_internal_shape(int index) const {
  return shape_.Get(index);
}
inline int32_t FloatTensor::shape(int index) const {
  // @@protoc_insertion_point(field_get:FloatTensor.shape)
  return _internal_shape(index);
}
inline void FloatTensor::set_shape(int index, int32_t value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:FloatTensor.shape)
}
inline void FloatTensor::_internal_add_shape(int32_t value) {
  shape_.Add(value);
}
inline void FloatTensor::add_shape(int32_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:FloatTensor.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
FloatTensor::_internal_shape() const {
  return shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
FloatTensor::shape() const {
  // @@protoc_insertion_point(field_list:FloatTensor.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
FloatTensor::_internal_mutable_shape() {
  return &shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
FloatTensor::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:FloatTensor.shape)
  return _internal_mutable_shape();
}

// repeated float array = 2;
inline int FloatTensor::_internal_array_size() const {
  return array_.size();
}
inline int FloatTensor::array_size() const {
  return _internal_array_size();
}
inline void FloatTensor::clear_array() {
  array_.Clear();
}
inline float FloatTensor::_internal_array(int index) const {
  return array_.Get(index);
}
inline float FloatTensor::array(int index) const {
  // @@protoc_insertion_point(field_get:FloatTensor.array)
  return _internal_array(index);
}
inline void FloatTensor::set_array(int index, float value) {
  array_.Set(index, value);
  // @@protoc_insertion_point(field_set:FloatTensor.array)
}
inline void FloatTensor::_internal_add_array(float value) {
  array_.Add(value);
}
inline void FloatTensor::add_array(float value) {
  _internal_add_array(value);
  // @@protoc_insertion_point(field_add:FloatTensor.array)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
FloatTensor::_internal_array() const {
  return array_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
FloatTensor::array() const {
  // @@protoc_insertion_point(field_list:FloatTensor.array)
  return _internal_array();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
FloatTensor::_internal_mutable_array() {
  return &array_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
FloatTensor::mutable_array() {
  // @@protoc_insertion_point(field_mutable_list:FloatTensor.array)
  return _internal_mutable_array();
}

// -------------------------------------------------------------------

// IntTensor

// repeated int32 shape = 1;
inline int IntTensor::_internal_shape_size() const {
  return shape_.size();
}
inline int IntTensor::shape_size() const {
  return _internal_shape_size();
}
inline void IntTensor::clear_shape() {
  shape_.Clear();
}
inline int32_t IntTensor::_internal_shape(int index) const {
  return shape_.Get(index);
}
inline int32_t IntTensor::shape(int index) const {
  // @@protoc_insertion_point(field_get:IntTensor.shape)
  return _internal_shape(index);
}
inline void IntTensor::set_shape(int index, int32_t value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:IntTensor.shape)
}
inline void IntTensor::_internal_add_shape(int32_t value) {
  shape_.Add(value);
}
inline void IntTensor::add_shape(int32_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:IntTensor.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
IntTensor::_internal_shape() const {
  return shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
IntTensor::shape() const {
  // @@protoc_insertion_point(field_list:IntTensor.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
IntTensor::_internal_mutable_shape() {
  return &shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
IntTensor::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:IntTensor.shape)
  return _internal_mutable_shape();
}

// repeated int32 array = 2;
inline int IntTensor::_internal_array_size() const {
  return array_.size();
}
inline int IntTensor::array_size() const {
  return _internal_array_size();
}
inline void IntTensor::clear_array() {
  array_.Clear();
}
inline int32_t IntTensor::_internal_array(int index) const {
  return array_.Get(index);
}
inline int32_t IntTensor::array(int index) const {
  // @@protoc_insertion_point(field_get:IntTensor.array)
  return _internal_array(index);
}
inline void IntTensor::set_array(int index, int32_t value) {
  array_.Set(index, value);
  // @@protoc_insertion_point(field_set:IntTensor.array)
}
inline void IntTensor::_internal_add_array(int32_t value) {
  array_.Add(value);
}
inline void IntTensor::add_array(int32_t value) {
  _internal_add_array(value);
  // @@protoc_insertion_point(field_add:IntTensor.array)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
IntTensor::_internal_array() const {
  return array_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
IntTensor::array() const {
  // @@protoc_insertion_point(field_list:IntTensor.array)
  return _internal_array();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
IntTensor::_internal_mutable_array() {
  return &array_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
IntTensor::mutable_array() {
  // @@protoc_insertion_point(field_mutable_list:IntTensor.array)
  return _internal_mutable_array();
}

// -------------------------------------------------------------------

// BoolTensor

// repeated int32 shape = 1;
inline int BoolTensor::_internal_shape_size() const {
  return shape_.size();
}
inline int BoolTensor::shape_size() const {
  return _internal_shape_size();
}
inline void BoolTensor::clear_shape() {
  shape_.Clear();
}
inline int32_t BoolTensor::_internal_shape(int index) const {
  return shape_.Get(index);
}
inline int32_t BoolTensor::shape(int index) const {
  // @@protoc_insertion_point(field_get:BoolTensor.shape)
  return _internal_shape(index);
}
inline void BoolTensor::set_shape(int index, int32_t value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:BoolTensor.shape)
}
inline void BoolTensor::_internal_add_shape(int32_t value) {
  shape_.Add(value);
}
inline void BoolTensor::add_shape(int32_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:BoolTensor.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
BoolTensor::_internal_shape() const {
  return shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
BoolTensor::shape() const {
  // @@protoc_insertion_point(field_list:BoolTensor.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
BoolTensor::_internal_mutable_shape() {
  return &shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
BoolTensor::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:BoolTensor.shape)
  return _internal_mutable_shape();
}

// repeated bool array = 2;
inline int BoolTensor::_internal_array_size() const {
  return array_.size();
}
inline int BoolTensor::array_size() const {
  return _internal_array_size();
}
inline void BoolTensor::clear_array() {
  array_.Clear();
}
inline bool BoolTensor::_internal_array(int index) const {
  return array_.Get(index);
}
inline bool BoolTensor::array(int index) const {
  // @@protoc_insertion_point(field_get:BoolTensor.array)
  return _internal_array(index);
}
inline void BoolTensor::set_array(int index, bool value) {
  array_.Set(index, value);
  // @@protoc_insertion_point(field_set:BoolTensor.array)
}
inline void BoolTensor::_internal_add_array(bool value) {
  array_.Add(value);
}
inline void BoolTensor::add_array(bool value) {
  _internal_add_array(value);
  // @@protoc_insertion_point(field_add:BoolTensor.array)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
BoolTensor::_internal_array() const {
  return array_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
BoolTensor::array() const {
  // @@protoc_insertion_point(field_list:BoolTensor.array)
  return _internal_array();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
BoolTensor::_internal_mutable_array() {
  return &array_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
BoolTensor::mutable_array() {
  // @@protoc_insertion_point(field_mutable_list:BoolTensor.array)
  return _internal_mutable_array();
}

// -------------------------------------------------------------------

// GraphSpace

// .Space node_space = 1;
inline bool GraphSpace::_internal_has_node_space() const {
  return this != internal_default_instance() && node_space_ != nullptr;
}
inline bool GraphSpace::has_node_space() const {
  return _internal_has_node_space();
}
inline void GraphSpace::clear_node_space() {
  if (GetArenaForAllocation() == nullptr && node_space_ != nullptr) {
    delete node_space_;
  }
  node_space_ = nullptr;
}
inline const ::Space& GraphSpace::_internal_node_space() const {
  const ::Space* p = node_space_;
  return p != nullptr ? *p : reinterpret_cast<const ::Space&>(
      ::_Space_default_instance_);
}
inline const ::Space& GraphSpace::node_space() const {
  // @@protoc_insertion_point(field_get:GraphSpace.node_space)
  return _internal_node_space();
}
inline void GraphSpace::unsafe_arena_set_allocated_node_space(
    ::Space* node_space) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_space_);
  }
  node_space_ = node_space;
  if (node_space) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GraphSpace.node_space)
}
inline ::Space* GraphSpace::release_node_space() {
  
  ::Space* temp = node_space_;
  node_space_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Space* GraphSpace::unsafe_arena_release_node_space() {
  // @@protoc_insertion_point(field_release:GraphSpace.node_space)
  
  ::Space* temp = node_space_;
  node_space_ = nullptr;
  return temp;
}
inline ::Space* GraphSpace::_internal_mutable_node_space() {
  
  if (node_space_ == nullptr) {
    auto* p = CreateMaybeMessage<::Space>(GetArenaForAllocation());
    node_space_ = p;
  }
  return node_space_;
}
inline ::Space* GraphSpace::mutable_node_space() {
  ::Space* _msg = _internal_mutable_node_space();
  // @@protoc_insertion_point(field_mutable:GraphSpace.node_space)
  return _msg;
}
inline void GraphSpace::set_allocated_node_space(::Space* node_space) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete node_space_;
  }
  if (node_space) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Space>::GetOwningArena(node_space);
    if (message_arena != submessage_arena) {
      node_space = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node_space, submessage_arena);
    }
    
  } else {
    
  }
  node_space_ = node_space;
  // @@protoc_insertion_point(field_set_allocated:GraphSpace.node_space)
}

// .Space edge_space = 2;
inline bool GraphSpace::_internal_has_edge_space() const {
  return this != internal_default_instance() && edge_space_ != nullptr;
}
inline bool GraphSpace::has_edge_space() const {
  return _internal_has_edge_space();
}
inline void GraphSpace::clear_edge_space() {
  if (GetArenaForAllocation() == nullptr && edge_space_ != nullptr) {
    delete edge_space_;
  }
  edge_space_ = nullptr;
}
inline const ::Space& GraphSpace::_internal_edge_space() const {
  const ::Space* p = edge_space_;
  return p != nullptr ? *p : reinterpret_cast<const ::Space&>(
      ::_Space_default_instance_);
}
inline const ::Space& GraphSpace::edge_space() const {
  // @@protoc_insertion_point(field_get:GraphSpace.edge_space)
  return _internal_edge_space();
}
inline void GraphSpace::unsafe_arena_set_allocated_edge_space(
    ::Space* edge_space) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(edge_space_);
  }
  edge_space_ = edge_space;
  if (edge_space) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GraphSpace.edge_space)
}
inline ::Space* GraphSpace::release_edge_space() {
  
  ::Space* temp = edge_space_;
  edge_space_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Space* GraphSpace::unsafe_arena_release_edge_space() {
  // @@protoc_insertion_point(field_release:GraphSpace.edge_space)
  
  ::Space* temp = edge_space_;
  edge_space_ = nullptr;
  return temp;
}
inline ::Space* GraphSpace::_internal_mutable_edge_space() {
  
  if (edge_space_ == nullptr) {
    auto* p = CreateMaybeMessage<::Space>(GetArenaForAllocation());
    edge_space_ = p;
  }
  return edge_space_;
}
inline ::Space* GraphSpace::mutable_edge_space() {
  ::Space* _msg = _internal_mutable_edge_space();
  // @@protoc_insertion_point(field_mutable:GraphSpace.edge_space)
  return _msg;
}
inline void GraphSpace::set_allocated_edge_space(::Space* edge_space) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete edge_space_;
  }
  if (edge_space) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Space>::GetOwningArena(edge_space);
    if (message_arena != submessage_arena) {
      edge_space = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edge_space, submessage_arena);
    }
    
  } else {
    
  }
  edge_space_ = edge_space;
  // @@protoc_insertion_point(field_set_allocated:GraphSpace.edge_space)
}

// -------------------------------------------------------------------

// Graph

// .FloatTensor nodes = 1;
inline bool Graph::_internal_has_nodes() const {
  return this != internal_default_instance() && nodes_ != nullptr;
}
inline bool Graph::has_nodes() const {
  return _internal_has_nodes();
}
inline void Graph::clear_nodes() {
  if (GetArenaForAllocation() == nullptr && nodes_ != nullptr) {
    delete nodes_;
  }
  nodes_ = nullptr;
}
inline const ::FloatTensor& Graph::_internal_nodes() const {
  const ::FloatTensor* p = nodes_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatTensor&>(
      ::_FloatTensor_default_instance_);
}
inline const ::FloatTensor& Graph::nodes() const {
  // @@protoc_insertion_point(field_get:Graph.nodes)
  return _internal_nodes();
}
inline void Graph::unsafe_arena_set_allocated_nodes(
    ::FloatTensor* nodes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nodes_);
  }
  nodes_ = nodes;
  if (nodes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Graph.nodes)
}
inline ::FloatTensor* Graph::release_nodes() {
  
  ::FloatTensor* temp = nodes_;
  nodes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::FloatTensor* Graph::unsafe_arena_release_nodes() {
  // @@protoc_insertion_point(field_release:Graph.nodes)
  
  ::FloatTensor* temp = nodes_;
  nodes_ = nullptr;
  return temp;
}
inline ::FloatTensor* Graph::_internal_mutable_nodes() {
  
  if (nodes_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatTensor>(GetArenaForAllocation());
    nodes_ = p;
  }
  return nodes_;
}
inline ::FloatTensor* Graph::mutable_nodes() {
  ::FloatTensor* _msg = _internal_mutable_nodes();
  // @@protoc_insertion_point(field_mutable:Graph.nodes)
  return _msg;
}
inline void Graph::set_allocated_nodes(::FloatTensor* nodes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete nodes_;
  }
  if (nodes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::FloatTensor>::GetOwningArena(nodes);
    if (message_arena != submessage_arena) {
      nodes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nodes, submessage_arena);
    }
    
  } else {
    
  }
  nodes_ = nodes;
  // @@protoc_insertion_point(field_set_allocated:Graph.nodes)
}

// .FloatTensor edges = 2;
inline bool Graph::_internal_has_edges() const {
  return this != internal_default_instance() && edges_ != nullptr;
}
inline bool Graph::has_edges() const {
  return _internal_has_edges();
}
inline void Graph::clear_edges() {
  if (GetArenaForAllocation() == nullptr && edges_ != nullptr) {
    delete edges_;
  }
  edges_ = nullptr;
}
inline const ::FloatTensor& Graph::_internal_edges() const {
  const ::FloatTensor* p = edges_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatTensor&>(
      ::_FloatTensor_default_instance_);
}
inline const ::FloatTensor& Graph::edges() const {
  // @@protoc_insertion_point(field_get:Graph.edges)
  return _internal_edges();
}
inline void Graph::unsafe_arena_set_allocated_edges(
    ::FloatTensor* edges) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(edges_);
  }
  edges_ = edges;
  if (edges) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Graph.edges)
}
inline ::FloatTensor* Graph::release_edges() {
  
  ::FloatTensor* temp = edges_;
  edges_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::FloatTensor* Graph::unsafe_arena_release_edges() {
  // @@protoc_insertion_point(field_release:Graph.edges)
  
  ::FloatTensor* temp = edges_;
  edges_ = nullptr;
  return temp;
}
inline ::FloatTensor* Graph::_internal_mutable_edges() {
  
  if (edges_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatTensor>(GetArenaForAllocation());
    edges_ = p;
  }
  return edges_;
}
inline ::FloatTensor* Graph::mutable_edges() {
  ::FloatTensor* _msg = _internal_mutable_edges();
  // @@protoc_insertion_point(field_mutable:Graph.edges)
  return _msg;
}
inline void Graph::set_allocated_edges(::FloatTensor* edges) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete edges_;
  }
  if (edges) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::FloatTensor>::GetOwningArena(edges);
    if (message_arena != submessage_arena) {
      edges = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edges, submessage_arena);
    }
    
  } else {
    
  }
  edges_ = edges;
  // @@protoc_insertion_point(field_set_allocated:Graph.edges)
}

// .IntTensor edge_links = 3;
inline bool Graph::_internal_has_edge_links() const {
  return this != internal_default_instance() && edge_links_ != nullptr;
}
inline bool Graph::has_edge_links() const {
  return _internal_has_edge_links();
}
inline void Graph::clear_edge_links() {
  if (GetArenaForAllocation() == nullptr && edge_links_ != nullptr) {
    delete edge_links_;
  }
  edge_links_ = nullptr;
}
inline const ::IntTensor& Graph::_internal_edge_links() const {
  const ::IntTensor* p = edge_links_;
  return p != nullptr ? *p : reinterpret_cast<const ::IntTensor&>(
      ::_IntTensor_default_instance_);
}
inline const ::IntTensor& Graph::edge_links() const {
  // @@protoc_insertion_point(field_get:Graph.edge_links)
  return _internal_edge_links();
}
inline void Graph::unsafe_arena_set_allocated_edge_links(
    ::IntTensor* edge_links) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(edge_links_);
  }
  edge_links_ = edge_links;
  if (edge_links) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Graph.edge_links)
}
inline ::IntTensor* Graph::release_edge_links() {
  
  ::IntTensor* temp = edge_links_;
  edge_links_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::IntTensor* Graph::unsafe_arena_release_edge_links() {
  // @@protoc_insertion_point(field_release:Graph.edge_links)
  
  ::IntTensor* temp = edge_links_;
  edge_links_ = nullptr;
  return temp;
}
inline ::IntTensor* Graph::_internal_mutable_edge_links() {
  
  if (edge_links_ == nullptr) {
    auto* p = CreateMaybeMessage<::IntTensor>(GetArenaForAllocation());
    edge_links_ = p;
  }
  return edge_links_;
}
inline ::IntTensor* Graph::mutable_edge_links() {
  ::IntTensor* _msg = _internal_mutable_edge_links();
  // @@protoc_insertion_point(field_mutable:Graph.edge_links)
  return _msg;
}
inline void Graph::set_allocated_edge_links(::IntTensor* edge_links) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete edge_links_;
  }
  if (edge_links) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::IntTensor>::GetOwningArena(edge_links);
    if (message_arena != submessage_arena) {
      edge_links = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edge_links, submessage_arena);
    }
    
  } else {
    
  }
  edge_links_ = edge_links;
  // @@protoc_insertion_point(field_set_allocated:Graph.edge_links)
}

// -------------------------------------------------------------------

// Image

// .CompressionType compression_type = 1;
inline void Image::clear_compression_type() {
  compression_type_ = 0;
}
inline ::CompressionType Image::_internal_compression_type() const {
  return static_cast< ::CompressionType >(compression_type_);
}
inline ::CompressionType Image::compression_type() const {
  // @@protoc_insertion_point(field_get:Image.compression_type)
  return _internal_compression_type();
}
inline void Image::_internal_set_compression_type(::CompressionType value) {
  
  compression_type_ = value;
}
inline void Image::set_compression_type(::CompressionType value) {
  _internal_set_compression_type(value);
  // @@protoc_insertion_point(field_set:Image.compression_type)
}

// bytes data = 2;
inline void Image::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& Image::data() const {
  // @@protoc_insertion_point(field_get:Image.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Image::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Image.data)
}
inline std::string* Image::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:Image.data)
  return _s;
}
inline const std::string& Image::_internal_data() const {
  return data_.Get();
}
inline void Image::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Image::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Image::release_data() {
  // @@protoc_insertion_point(field_release:Image.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Image::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Image.data)
}

// repeated int32 shape = 3;
inline int Image::_internal_shape_size() const {
  return shape_.size();
}
inline int Image::shape_size() const {
  return _internal_shape_size();
}
inline void Image::clear_shape() {
  shape_.Clear();
}
inline int32_t Image::_internal_shape(int index) const {
  return shape_.Get(index);
}
inline int32_t Image::shape(int index) const {
  // @@protoc_insertion_point(field_get:Image.shape)
  return _internal_shape(index);
}
inline void Image::set_shape(int index, int32_t value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:Image.shape)
}
inline void Image::_internal_add_shape(int32_t value) {
  shape_.Add(value);
}
inline void Image::add_shape(int32_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:Image.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Image::_internal_shape() const {
  return shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Image::shape() const {
  // @@protoc_insertion_point(field_list:Image.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Image::_internal_mutable_shape() {
  return &shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Image::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:Image.shape)
  return _internal_mutable_shape();
}

// repeated int32 dimension_mapping = 4;
inline int Image::_internal_dimension_mapping_size() const {
  return dimension_mapping_.size();
}
inline int Image::dimension_mapping_size() const {
  return _internal_dimension_mapping_size();
}
inline void Image::clear_dimension_mapping() {
  dimension_mapping_.Clear();
}
inline int32_t Image::_internal_dimension_mapping(int index) const {
  return dimension_mapping_.Get(index);
}
inline int32_t Image::dimension_mapping(int index) const {
  // @@protoc_insertion_point(field_get:Image.dimension_mapping)
  return _internal_dimension_mapping(index);
}
inline void Image::set_dimension_mapping(int index, int32_t value) {
  dimension_mapping_.Set(index, value);
  // @@protoc_insertion_point(field_set:Image.dimension_mapping)
}
inline void Image::_internal_add_dimension_mapping(int32_t value) {
  dimension_mapping_.Add(value);
}
inline void Image::add_dimension_mapping(int32_t value) {
  _internal_add_dimension_mapping(value);
  // @@protoc_insertion_point(field_add:Image.dimension_mapping)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Image::_internal_dimension_mapping() const {
  return dimension_mapping_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Image::dimension_mapping() const {
  // @@protoc_insertion_point(field_list:Image.dimension_mapping)
  return _internal_dimension_mapping();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Image::_internal_mutable_dimension_mapping() {
  return &dimension_mapping_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Image::mutable_dimension_mapping() {
  // @@protoc_insertion_point(field_mutable_list:Image.dimension_mapping)
  return _internal_mutable_dimension_mapping();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Space

// .SpaceType space_type = 1;
inline void Space::clear_space_type() {
  space_type_ = 0;
}
inline ::SpaceType Space::_internal_space_type() const {
  return static_cast< ::SpaceType >(space_type_);
}
inline ::SpaceType Space::space_type() const {
  // @@protoc_insertion_point(field_get:Space.space_type)
  return _internal_space_type();
}
inline void Space::_internal_set_space_type(::SpaceType value) {
  
  space_type_ = value;
}
inline void Space::set_space_type(::SpaceType value) {
  _internal_set_space_type(value);
  // @@protoc_insertion_point(field_set:Space.space_type)
}

// repeated int32 shape = 2;
inline int Space::_internal_shape_size() const {
  return shape_.size();
}
inline int Space::shape_size() const {
  return _internal_shape_size();
}
inline void Space::clear_shape() {
  shape_.Clear();
}
inline int32_t Space::_internal_shape(int index) const {
  return shape_.Get(index);
}
inline int32_t Space::shape(int index) const {
  // @@protoc_insertion_point(field_get:Space.shape)
  return _internal_shape(index);
}
inline void Space::set_shape(int index, int32_t value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:Space.shape)
}
inline void Space::_internal_add_shape(int32_t value) {
  shape_.Add(value);
}
inline void Space::add_shape(int32_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:Space.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Space::_internal_shape() const {
  return shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Space::shape() const {
  // @@protoc_insertion_point(field_list:Space.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Space::_internal_mutable_shape() {
  return &shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Space::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:Space.shape)
  return _internal_mutable_shape();
}

// .DataType data_type = 3;
inline void Space::clear_data_type() {
  data_type_ = 0;
}
inline ::DataType Space::_internal_data_type() const {
  return static_cast< ::DataType >(data_type_);
}
inline ::DataType Space::data_type() const {
  // @@protoc_insertion_point(field_get:Space.data_type)
  return _internal_data_type();
}
inline void Space::_internal_set_data_type(::DataType value) {
  
  data_type_ = value;
}
inline void Space::set_data_type(::DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:Space.data_type)
}

// repeated float low = 4;
inline int Space::_internal_low_size() const {
  return low_.size();
}
inline int Space::low_size() const {
  return _internal_low_size();
}
inline void Space::clear_low() {
  low_.Clear();
}
inline float Space::_internal_low(int index) const {
  return low_.Get(index);
}
inline float Space::low(int index) const {
  // @@protoc_insertion_point(field_get:Space.low)
  return _internal_low(index);
}
inline void Space::set_low(int index, float value) {
  low_.Set(index, value);
  // @@protoc_insertion_point(field_set:Space.low)
}
inline void Space::_internal_add_low(float value) {
  low_.Add(value);
}
inline void Space::add_low(float value) {
  _internal_add_low(value);
  // @@protoc_insertion_point(field_add:Space.low)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Space::_internal_low() const {
  return low_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Space::low() const {
  // @@protoc_insertion_point(field_list:Space.low)
  return _internal_low();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Space::_internal_mutable_low() {
  return &low_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Space::mutable_low() {
  // @@protoc_insertion_point(field_mutable_list:Space.low)
  return _internal_mutable_low();
}

// repeated float high = 5;
inline int Space::_internal_high_size() const {
  return high_.size();
}
inline int Space::high_size() const {
  return _internal_high_size();
}
inline void Space::clear_high() {
  high_.Clear();
}
inline float Space::_internal_high(int index) const {
  return high_.Get(index);
}
inline float Space::high(int index) const {
  // @@protoc_insertion_point(field_get:Space.high)
  return _internal_high(index);
}
inline void Space::set_high(int index, float value) {
  high_.Set(index, value);
  // @@protoc_insertion_point(field_set:Space.high)
}
inline void Space::_internal_add_high(float value) {
  high_.Add(value);
}
inline void Space::add_high(float value) {
  _internal_add_high(value);
  // @@protoc_insertion_point(field_add:Space.high)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Space::_internal_high() const {
  return high_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Space::high() const {
  // @@protoc_insertion_point(field_list:Space.high)
  return _internal_high();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Space::_internal_mutable_high() {
  return &high_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Space::mutable_high() {
  // @@protoc_insertion_point(field_mutable_list:Space.high)
  return _internal_mutable_high();
}

// int32 min = 6;
inline void Space::clear_min() {
  min_ = 0;
}
inline int32_t Space::_internal_min() const {
  return min_;
}
inline int32_t Space::min() const {
  // @@protoc_insertion_point(field_get:Space.min)
  return _internal_min();
}
inline void Space::_internal_set_min(int32_t value) {
  
  min_ = value;
}
inline void Space::set_min(int32_t value) {
  _internal_set_min(value);
  // @@protoc_insertion_point(field_set:Space.min)
}

// int32 max = 7;
inline void Space::clear_max() {
  max_ = 0;
}
inline int32_t Space::_internal_max() const {
  return max_;
}
inline int32_t Space::max() const {
  // @@protoc_insertion_point(field_get:Space.max)
  return _internal_max();
}
inline void Space::_internal_set_max(int32_t value) {
  
  max_ = value;
}
inline void Space::set_max(int32_t value) {
  _internal_set_max(value);
  // @@protoc_insertion_point(field_set:Space.max)
}

// repeated int32 nvec = 8;
inline int Space::_internal_nvec_size() const {
  return nvec_.size();
}
inline int Space::nvec_size() const {
  return _internal_nvec_size();
}
inline void Space::clear_nvec() {
  nvec_.Clear();
}
inline int32_t Space::_internal_nvec(int index) const {
  return nvec_.Get(index);
}
inline int32_t Space::nvec(int index) const {
  // @@protoc_insertion_point(field_get:Space.nvec)
  return _internal_nvec(index);
}
inline void Space::set_nvec(int index, int32_t value) {
  nvec_.Set(index, value);
  // @@protoc_insertion_point(field_set:Space.nvec)
}
inline void Space::_internal_add_nvec(int32_t value) {
  nvec_.Add(value);
}
inline void Space::add_nvec(int32_t value) {
  _internal_add_nvec(value);
  // @@protoc_insertion_point(field_add:Space.nvec)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Space::_internal_nvec() const {
  return nvec_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Space::nvec() const {
  // @@protoc_insertion_point(field_list:Space.nvec)
  return _internal_nvec();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Space::_internal_mutable_nvec() {
  return &nvec_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Space::mutable_nvec() {
  // @@protoc_insertion_point(field_mutable_list:Space.nvec)
  return _internal_mutable_nvec();
}

// repeated string charset = 9;
inline int Space::_internal_charset_size() const {
  return charset_.size();
}
inline int Space::charset_size() const {
  return _internal_charset_size();
}
inline void Space::clear_charset() {
  charset_.Clear();
}
inline std::string* Space::add_charset() {
  std::string* _s = _internal_add_charset();
  // @@protoc_insertion_point(field_add_mutable:Space.charset)
  return _s;
}
inline const std::string& Space::_internal_charset(int index) const {
  return charset_.Get(index);
}
inline const std::string& Space::charset(int index) const {
  // @@protoc_insertion_point(field_get:Space.charset)
  return _internal_charset(index);
}
inline std::string* Space::mutable_charset(int index) {
  // @@protoc_insertion_point(field_mutable:Space.charset)
  return charset_.Mutable(index);
}
inline void Space::set_charset(int index, const std::string& value) {
  charset_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Space.charset)
}
inline void Space::set_charset(int index, std::string&& value) {
  charset_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Space.charset)
}
inline void Space::set_charset(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  charset_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Space.charset)
}
inline void Space::set_charset(int index, const char* value, size_t size) {
  charset_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Space.charset)
}
inline std::string* Space::_internal_add_charset() {
  return charset_.Add();
}
inline void Space::add_charset(const std::string& value) {
  charset_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Space.charset)
}
inline void Space::add_charset(std::string&& value) {
  charset_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Space.charset)
}
inline void Space::add_charset(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  charset_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Space.charset)
}
inline void Space::add_charset(const char* value, size_t size) {
  charset_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Space.charset)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Space::charset() const {
  // @@protoc_insertion_point(field_list:Space.charset)
  return charset_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Space::mutable_charset() {
  // @@protoc_insertion_point(field_mutable_list:Space.charset)
  return &charset_;
}

// map<string, .Space> dict_space = 10;
inline int Space::_internal_dict_space_size() const {
  return dict_space_.size();
}
inline int Space::dict_space_size() const {
  return _internal_dict_space_size();
}
inline void Space::clear_dict_space() {
  dict_space_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Space >&
Space::_internal_dict_space() const {
  return dict_space_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Space >&
Space::dict_space() const {
  // @@protoc_insertion_point(field_map:Space.dict_space)
  return _internal_dict_space();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Space >*
Space::_internal_mutable_dict_space() {
  return dict_space_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Space >*
Space::mutable_dict_space() {
  // @@protoc_insertion_point(field_mutable_map:Space.dict_space)
  return _internal_mutable_dict_space();
}

// map<int32, .Space> list_space = 11;
inline int Space::_internal_list_space_size() const {
  return list_space_.size();
}
inline int Space::list_space_size() const {
  return _internal_list_space_size();
}
inline void Space::clear_list_space() {
  list_space_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::Space >&
Space::_internal_list_space() const {
  return list_space_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::Space >&
Space::list_space() const {
  // @@protoc_insertion_point(field_map:Space.list_space)
  return _internal_list_space();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::Space >*
Space::_internal_mutable_list_space() {
  return list_space_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::Space >*
Space::mutable_list_space() {
  // @@protoc_insertion_point(field_mutable_map:Space.list_space)
  return _internal_mutable_list_space();
}

// .GraphSpace graph_space = 12;
inline bool Space::_internal_has_graph_space() const {
  return this != internal_default_instance() && graph_space_ != nullptr;
}
inline bool Space::has_graph_space() const {
  return _internal_has_graph_space();
}
inline void Space::clear_graph_space() {
  if (GetArenaForAllocation() == nullptr && graph_space_ != nullptr) {
    delete graph_space_;
  }
  graph_space_ = nullptr;
}
inline const ::GraphSpace& Space::_internal_graph_space() const {
  const ::GraphSpace* p = graph_space_;
  return p != nullptr ? *p : reinterpret_cast<const ::GraphSpace&>(
      ::_GraphSpace_default_instance_);
}
inline const ::GraphSpace& Space::graph_space() const {
  // @@protoc_insertion_point(field_get:Space.graph_space)
  return _internal_graph_space();
}
inline void Space::unsafe_arena_set_allocated_graph_space(
    ::GraphSpace* graph_space) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(graph_space_);
  }
  graph_space_ = graph_space;
  if (graph_space) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Space.graph_space)
}
inline ::GraphSpace* Space::release_graph_space() {
  
  ::GraphSpace* temp = graph_space_;
  graph_space_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GraphSpace* Space::unsafe_arena_release_graph_space() {
  // @@protoc_insertion_point(field_release:Space.graph_space)
  
  ::GraphSpace* temp = graph_space_;
  graph_space_ = nullptr;
  return temp;
}
inline ::GraphSpace* Space::_internal_mutable_graph_space() {
  
  if (graph_space_ == nullptr) {
    auto* p = CreateMaybeMessage<::GraphSpace>(GetArenaForAllocation());
    graph_space_ = p;
  }
  return graph_space_;
}
inline ::GraphSpace* Space::mutable_graph_space() {
  ::GraphSpace* _msg = _internal_mutable_graph_space();
  // @@protoc_insertion_point(field_mutable:Space.graph_space)
  return _msg;
}
inline void Space::set_allocated_graph_space(::GraphSpace* graph_space) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete graph_space_;
  }
  if (graph_space) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::GraphSpace>::GetOwningArena(graph_space);
    if (message_arena != submessage_arena) {
      graph_space = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, graph_space, submessage_arena);
    }
    
  } else {
    
  }
  graph_space_ = graph_space;
  // @@protoc_insertion_point(field_set_allocated:Space.graph_space)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Data

// .SpaceType space_type = 1;
inline void Data::clear_space_type() {
  space_type_ = 0;
}
inline ::SpaceType Data::_internal_space_type() const {
  return static_cast< ::SpaceType >(space_type_);
}
inline ::SpaceType Data::space_type() const {
  // @@protoc_insertion_point(field_get:Data.space_type)
  return _internal_space_type();
}
inline void Data::_internal_set_space_type(::SpaceType value) {
  
  space_type_ = value;
}
inline void Data::set_space_type(::SpaceType value) {
  _internal_set_space_type(value);
  // @@protoc_insertion_point(field_set:Data.space_type)
}

// .FloatTensor box = 2;
inline bool Data::_internal_has_box() const {
  return this != internal_default_instance() && box_ != nullptr;
}
inline bool Data::has_box() const {
  return _internal_has_box();
}
inline void Data::clear_box() {
  if (GetArenaForAllocation() == nullptr && box_ != nullptr) {
    delete box_;
  }
  box_ = nullptr;
}
inline const ::FloatTensor& Data::_internal_box() const {
  const ::FloatTensor* p = box_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatTensor&>(
      ::_FloatTensor_default_instance_);
}
inline const ::FloatTensor& Data::box() const {
  // @@protoc_insertion_point(field_get:Data.box)
  return _internal_box();
}
inline void Data::unsafe_arena_set_allocated_box(
    ::FloatTensor* box) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(box_);
  }
  box_ = box;
  if (box) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Data.box)
}
inline ::FloatTensor* Data::release_box() {
  
  ::FloatTensor* temp = box_;
  box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::FloatTensor* Data::unsafe_arena_release_box() {
  // @@protoc_insertion_point(field_release:Data.box)
  
  ::FloatTensor* temp = box_;
  box_ = nullptr;
  return temp;
}
inline ::FloatTensor* Data::_internal_mutable_box() {
  
  if (box_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatTensor>(GetArenaForAllocation());
    box_ = p;
  }
  return box_;
}
inline ::FloatTensor* Data::mutable_box() {
  ::FloatTensor* _msg = _internal_mutable_box();
  // @@protoc_insertion_point(field_mutable:Data.box)
  return _msg;
}
inline void Data::set_allocated_box(::FloatTensor* box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete box_;
  }
  if (box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::FloatTensor>::GetOwningArena(box);
    if (message_arena != submessage_arena) {
      box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, box, submessage_arena);
    }
    
  } else {
    
  }
  box_ = box;
  // @@protoc_insertion_point(field_set_allocated:Data.box)
}

// int32 discrete = 3;
inline void Data::clear_discrete() {
  discrete_ = 0;
}
inline int32_t Data::_internal_discrete() const {
  return discrete_;
}
inline int32_t Data::discrete() const {
  // @@protoc_insertion_point(field_get:Data.discrete)
  return _internal_discrete();
}
inline void Data::_internal_set_discrete(int32_t value) {
  
  discrete_ = value;
}
inline void Data::set_discrete(int32_t value) {
  _internal_set_discrete(value);
  // @@protoc_insertion_point(field_set:Data.discrete)
}

// .BoolTensor multi_binary = 4;
inline bool Data::_internal_has_multi_binary() const {
  return this != internal_default_instance() && multi_binary_ != nullptr;
}
inline bool Data::has_multi_binary() const {
  return _internal_has_multi_binary();
}
inline void Data::clear_multi_binary() {
  if (GetArenaForAllocation() == nullptr && multi_binary_ != nullptr) {
    delete multi_binary_;
  }
  multi_binary_ = nullptr;
}
inline const ::BoolTensor& Data::_internal_multi_binary() const {
  const ::BoolTensor* p = multi_binary_;
  return p != nullptr ? *p : reinterpret_cast<const ::BoolTensor&>(
      ::_BoolTensor_default_instance_);
}
inline const ::BoolTensor& Data::multi_binary() const {
  // @@protoc_insertion_point(field_get:Data.multi_binary)
  return _internal_multi_binary();
}
inline void Data::unsafe_arena_set_allocated_multi_binary(
    ::BoolTensor* multi_binary) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(multi_binary_);
  }
  multi_binary_ = multi_binary;
  if (multi_binary) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Data.multi_binary)
}
inline ::BoolTensor* Data::release_multi_binary() {
  
  ::BoolTensor* temp = multi_binary_;
  multi_binary_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::BoolTensor* Data::unsafe_arena_release_multi_binary() {
  // @@protoc_insertion_point(field_release:Data.multi_binary)
  
  ::BoolTensor* temp = multi_binary_;
  multi_binary_ = nullptr;
  return temp;
}
inline ::BoolTensor* Data::_internal_mutable_multi_binary() {
  
  if (multi_binary_ == nullptr) {
    auto* p = CreateMaybeMessage<::BoolTensor>(GetArenaForAllocation());
    multi_binary_ = p;
  }
  return multi_binary_;
}
inline ::BoolTensor* Data::mutable_multi_binary() {
  ::BoolTensor* _msg = _internal_mutable_multi_binary();
  // @@protoc_insertion_point(field_mutable:Data.multi_binary)
  return _msg;
}
inline void Data::set_allocated_multi_binary(::BoolTensor* multi_binary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete multi_binary_;
  }
  if (multi_binary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::BoolTensor>::GetOwningArena(multi_binary);
    if (message_arena != submessage_arena) {
      multi_binary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, multi_binary, submessage_arena);
    }
    
  } else {
    
  }
  multi_binary_ = multi_binary;
  // @@protoc_insertion_point(field_set_allocated:Data.multi_binary)
}

// .IntTensor multi_discrete = 5;
inline bool Data::_internal_has_multi_discrete() const {
  return this != internal_default_instance() && multi_discrete_ != nullptr;
}
inline bool Data::has_multi_discrete() const {
  return _internal_has_multi_discrete();
}
inline void Data::clear_multi_discrete() {
  if (GetArenaForAllocation() == nullptr && multi_discrete_ != nullptr) {
    delete multi_discrete_;
  }
  multi_discrete_ = nullptr;
}
inline const ::IntTensor& Data::_internal_multi_discrete() const {
  const ::IntTensor* p = multi_discrete_;
  return p != nullptr ? *p : reinterpret_cast<const ::IntTensor&>(
      ::_IntTensor_default_instance_);
}
inline const ::IntTensor& Data::multi_discrete() const {
  // @@protoc_insertion_point(field_get:Data.multi_discrete)
  return _internal_multi_discrete();
}
inline void Data::unsafe_arena_set_allocated_multi_discrete(
    ::IntTensor* multi_discrete) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(multi_discrete_);
  }
  multi_discrete_ = multi_discrete;
  if (multi_discrete) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Data.multi_discrete)
}
inline ::IntTensor* Data::release_multi_discrete() {
  
  ::IntTensor* temp = multi_discrete_;
  multi_discrete_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::IntTensor* Data::unsafe_arena_release_multi_discrete() {
  // @@protoc_insertion_point(field_release:Data.multi_discrete)
  
  ::IntTensor* temp = multi_discrete_;
  multi_discrete_ = nullptr;
  return temp;
}
inline ::IntTensor* Data::_internal_mutable_multi_discrete() {
  
  if (multi_discrete_ == nullptr) {
    auto* p = CreateMaybeMessage<::IntTensor>(GetArenaForAllocation());
    multi_discrete_ = p;
  }
  return multi_discrete_;
}
inline ::IntTensor* Data::mutable_multi_discrete() {
  ::IntTensor* _msg = _internal_mutable_multi_discrete();
  // @@protoc_insertion_point(field_mutable:Data.multi_discrete)
  return _msg;
}
inline void Data::set_allocated_multi_discrete(::IntTensor* multi_discrete) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete multi_discrete_;
  }
  if (multi_discrete) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::IntTensor>::GetOwningArena(multi_discrete);
    if (message_arena != submessage_arena) {
      multi_discrete = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, multi_discrete, submessage_arena);
    }
    
  } else {
    
  }
  multi_discrete_ = multi_discrete;
  // @@protoc_insertion_point(field_set_allocated:Data.multi_discrete)
}

// string text = 6;
inline void Data::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& Data::text() const {
  // @@protoc_insertion_point(field_get:Data.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Data::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Data.text)
}
inline std::string* Data::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:Data.text)
  return _s;
}
inline const std::string& Data::_internal_text() const {
  return text_.Get();
}
inline void Data::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Data::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Data::release_text() {
  // @@protoc_insertion_point(field_release:Data.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Data::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Data.text)
}

// map<string, .Data> dict = 7;
inline int Data::_internal_dict_size() const {
  return dict_.size();
}
inline int Data::dict_size() const {
  return _internal_dict_size();
}
inline void Data::clear_dict() {
  dict_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Data >&
Data::_internal_dict() const {
  return dict_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Data >&
Data::dict() const {
  // @@protoc_insertion_point(field_map:Data.dict)
  return _internal_dict();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Data >*
Data::_internal_mutable_dict() {
  return dict_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::Data >*
Data::mutable_dict() {
  // @@protoc_insertion_point(field_mutable_map:Data.dict)
  return _internal_mutable_dict();
}

// map<int32, .Data> list = 8;
inline int Data::_internal_list_size() const {
  return list_.size();
}
inline int Data::list_size() const {
  return _internal_list_size();
}
inline void Data::clear_list() {
  list_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::Data >&
Data::_internal_list() const {
  return list_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::Data >&
Data::list() const {
  // @@protoc_insertion_point(field_map:Data.list)
  return _internal_list();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::Data >*
Data::_internal_mutable_list() {
  return list_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::Data >*
Data::mutable_list() {
  // @@protoc_insertion_point(field_mutable_map:Data.list)
  return _internal_mutable_list();
}

// .Graph graph = 9;
inline bool Data::_internal_has_graph() const {
  return this != internal_default_instance() && graph_ != nullptr;
}
inline bool Data::has_graph() const {
  return _internal_has_graph();
}
inline void Data::clear_graph() {
  if (GetArenaForAllocation() == nullptr && graph_ != nullptr) {
    delete graph_;
  }
  graph_ = nullptr;
}
inline const ::Graph& Data::_internal_graph() const {
  const ::Graph* p = graph_;
  return p != nullptr ? *p : reinterpret_cast<const ::Graph&>(
      ::_Graph_default_instance_);
}
inline const ::Graph& Data::graph() const {
  // @@protoc_insertion_point(field_get:Data.graph)
  return _internal_graph();
}
inline void Data::unsafe_arena_set_allocated_graph(
    ::Graph* graph) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(graph_);
  }
  graph_ = graph;
  if (graph) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Data.graph)
}
inline ::Graph* Data::release_graph() {
  
  ::Graph* temp = graph_;
  graph_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Graph* Data::unsafe_arena_release_graph() {
  // @@protoc_insertion_point(field_release:Data.graph)
  
  ::Graph* temp = graph_;
  graph_ = nullptr;
  return temp;
}
inline ::Graph* Data::_internal_mutable_graph() {
  
  if (graph_ == nullptr) {
    auto* p = CreateMaybeMessage<::Graph>(GetArenaForAllocation());
    graph_ = p;
  }
  return graph_;
}
inline ::Graph* Data::mutable_graph() {
  ::Graph* _msg = _internal_mutable_graph();
  // @@protoc_insertion_point(field_mutable:Data.graph)
  return _msg;
}
inline void Data::set_allocated_graph(::Graph* graph) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete graph_;
  }
  if (graph) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Graph>::GetOwningArena(graph);
    if (message_arena != submessage_arena) {
      graph = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, graph, submessage_arena);
    }
    
  } else {
    
  }
  graph_ = graph;
  // @@protoc_insertion_point(field_set_allocated:Data.graph)
}

// .Image image = 10;
inline bool Data::_internal_has_image() const {
  return this != internal_default_instance() && image_ != nullptr;
}
inline bool Data::has_image() const {
  return _internal_has_image();
}
inline void Data::clear_image() {
  if (GetArenaForAllocation() == nullptr && image_ != nullptr) {
    delete image_;
  }
  image_ = nullptr;
}
inline const ::Image& Data::_internal_image() const {
  const ::Image* p = image_;
  return p != nullptr ? *p : reinterpret_cast<const ::Image&>(
      ::_Image_default_instance_);
}
inline const ::Image& Data::image() const {
  // @@protoc_insertion_point(field_get:Data.image)
  return _internal_image();
}
inline void Data::unsafe_arena_set_allocated_image(
    ::Image* image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_);
  }
  image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Data.image)
}
inline ::Image* Data::release_image() {
  
  ::Image* temp = image_;
  image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Image* Data::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:Data.image)
  
  ::Image* temp = image_;
  image_ = nullptr;
  return temp;
}
inline ::Image* Data::_internal_mutable_image() {
  
  if (image_ == nullptr) {
    auto* p = CreateMaybeMessage<::Image>(GetArenaForAllocation());
    image_ = p;
  }
  return image_;
}
inline ::Image* Data::mutable_image() {
  ::Image* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:Data.image)
  return _msg;
}
inline void Data::set_allocated_image(::Image* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete image_;
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Image>::GetOwningArena(image);
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:Data.image)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::CompressionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CompressionType>() {
  return ::CompressionType_descriptor();
}
template <> struct is_proto_enum< ::SpaceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SpaceType>() {
  return ::SpaceType_descriptor();
}
template <> struct is_proto_enum< ::DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DataType>() {
  return ::DataType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_space_2eproto
