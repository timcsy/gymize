// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: locator.proto

#include "locator.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr SliceProto::SliceProto(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : start_(0)
  , stop_(0)
  , has_start_(false)
  , has_stop_(false)
  , is_index_(false)
  , is_ellipsis_(false)
  , step_(0)
  , is_new_axis_(false){}
struct SliceProtoDefaultTypeInternal {
  constexpr SliceProtoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SliceProtoDefaultTypeInternal() {}
  union {
    SliceProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SliceProtoDefaultTypeInternal _SliceProto_default_instance_;
constexpr SelectorProto::SelectorProto(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : slices_()
  , key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , type_(0)
{}
struct SelectorProtoDefaultTypeInternal {
  constexpr SelectorProtoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SelectorProtoDefaultTypeInternal() {}
  union {
    SelectorProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SelectorProtoDefaultTypeInternal _SelectorProto_default_instance_;
constexpr MappingProto::MappingProto(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : agents_()
  , destination_()
  , source_()
  , is_all_agents_(false)
  , is_root_(false){}
struct MappingProtoDefaultTypeInternal {
  constexpr MappingProtoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MappingProtoDefaultTypeInternal() {}
  union {
    MappingProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MappingProtoDefaultTypeInternal _MappingProto_default_instance_;
constexpr LocatorProto::LocatorProto(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mappings_(){}
struct LocatorProtoDefaultTypeInternal {
  constexpr LocatorProtoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LocatorProtoDefaultTypeInternal() {}
  union {
    LocatorProto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LocatorProtoDefaultTypeInternal _LocatorProto_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_locator_2eproto[4];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_locator_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_locator_2eproto = nullptr;

const uint32_t TableStruct_locator_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SliceProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SliceProto, has_start_),
  PROTOBUF_FIELD_OFFSET(::SliceProto, start_),
  PROTOBUF_FIELD_OFFSET(::SliceProto, has_stop_),
  PROTOBUF_FIELD_OFFSET(::SliceProto, stop_),
  PROTOBUF_FIELD_OFFSET(::SliceProto, step_),
  PROTOBUF_FIELD_OFFSET(::SliceProto, is_index_),
  PROTOBUF_FIELD_OFFSET(::SliceProto, is_ellipsis_),
  PROTOBUF_FIELD_OFFSET(::SliceProto, is_new_axis_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SelectorProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SelectorProto, type_),
  PROTOBUF_FIELD_OFFSET(::SelectorProto, slices_),
  PROTOBUF_FIELD_OFFSET(::SelectorProto, key_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::MappingProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::MappingProto, is_all_agents_),
  PROTOBUF_FIELD_OFFSET(::MappingProto, agents_),
  PROTOBUF_FIELD_OFFSET(::MappingProto, is_root_),
  PROTOBUF_FIELD_OFFSET(::MappingProto, destination_),
  PROTOBUF_FIELD_OFFSET(::MappingProto, source_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::LocatorProto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::LocatorProto, mappings_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::SliceProto)},
  { 14, -1, -1, sizeof(::SelectorProto)},
  { 23, -1, -1, sizeof(::MappingProto)},
  { 34, -1, -1, sizeof(::LocatorProto)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SliceProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SelectorProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_MappingProto_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_LocatorProto_default_instance_),
};

const char descriptor_table_protodef_locator_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\rlocator.proto\"\230\001\n\nSliceProto\022\021\n\thas_st"
  "art\030\001 \001(\010\022\r\n\005start\030\002 \001(\005\022\020\n\010has_stop\030\003 \001"
  "(\010\022\014\n\004stop\030\004 \001(\005\022\014\n\004step\030\005 \001(\005\022\020\n\010is_ind"
  "ex\030\006 \001(\010\022\023\n\013is_ellipsis\030\007 \001(\010\022\023\n\013is_new_"
  "axis\030\010 \001(\010\"[\n\rSelectorProto\022 \n\004type\030\001 \001("
  "\0162\022.SelectorTypeProto\022\033\n\006slices\030\002 \003(\0132\013."
  "SliceProto\022\013\n\003key\030\003 \001(\t\"\213\001\n\014MappingProto"
  "\022\025\n\ris_all_agents\030\001 \001(\010\022\016\n\006agents\030\002 \003(\t\022"
  "\017\n\007is_root\030\003 \001(\010\022#\n\013destination\030\004 \003(\0132\016."
  "SelectorProto\022\036\n\006source\030\005 \003(\0132\016.Selector"
  "Proto\"/\n\014LocatorProto\022\037\n\010mappings\030\001 \003(\0132"
  "\r.MappingProto*\267\001\n\021SelectorTypeProto\022#\n\037"
  "SELECTOR_TYPE_PROTO_UNSPECIFIED\020\000\022\034\n\030SEL"
  "ECTOR_TYPE_PROTO_DICT\020\001\022\035\n\031SELECTOR_TYPE"
  "_PROTO_TUPLE\020\002\022 \n\034SELECTOR_TYPE_PROTO_SE"
  "QUENCE\020\003\022\036\n\032SELECTOR_TYPE_PROTO_TENSOR\020\004"
  "B\022\252\002\017Gymize.Protobufb\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_locator_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_locator_2eproto = {
  false, false, 668, descriptor_table_protodef_locator_2eproto, "locator.proto", 
  &descriptor_table_locator_2eproto_once, nullptr, 0, 4,
  schemas, file_default_instances, TableStruct_locator_2eproto::offsets,
  file_level_metadata_locator_2eproto, file_level_enum_descriptors_locator_2eproto, file_level_service_descriptors_locator_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_locator_2eproto_getter() {
  return &descriptor_table_locator_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_locator_2eproto(&descriptor_table_locator_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SelectorTypeProto_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_locator_2eproto);
  return file_level_enum_descriptors_locator_2eproto[0];
}
bool SelectorTypeProto_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class SliceProto::_Internal {
 public:
};

SliceProto::SliceProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:SliceProto)
}
SliceProto::SliceProto(const SliceProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&start_, &from.start_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_new_axis_) -
    reinterpret_cast<char*>(&start_)) + sizeof(is_new_axis_));
  // @@protoc_insertion_point(copy_constructor:SliceProto)
}

inline void SliceProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&start_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_new_axis_) -
    reinterpret_cast<char*>(&start_)) + sizeof(is_new_axis_));
}

SliceProto::~SliceProto() {
  // @@protoc_insertion_point(destructor:SliceProto)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SliceProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SliceProto::ArenaDtor(void* object) {
  SliceProto* _this = reinterpret_cast< SliceProto* >(object);
  (void)_this;
}
void SliceProto::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SliceProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SliceProto::Clear() {
// @@protoc_insertion_point(message_clear_start:SliceProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&start_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_new_axis_) -
      reinterpret_cast<char*>(&start_)) + sizeof(is_new_axis_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SliceProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool has_start = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          has_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool has_stop = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          has_stop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 stop = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          stop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 step = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          step_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_index = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          is_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_ellipsis = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          is_ellipsis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_new_axis = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          is_new_axis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SliceProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SliceProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool has_start = 1;
  if (this->_internal_has_start() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_has_start(), target);
  }

  // int32 start = 2;
  if (this->_internal_start() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_start(), target);
  }

  // bool has_stop = 3;
  if (this->_internal_has_stop() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_has_stop(), target);
  }

  // int32 stop = 4;
  if (this->_internal_stop() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_stop(), target);
  }

  // int32 step = 5;
  if (this->_internal_step() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_step(), target);
  }

  // bool is_index = 6;
  if (this->_internal_is_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_is_index(), target);
  }

  // bool is_ellipsis = 7;
  if (this->_internal_is_ellipsis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_is_ellipsis(), target);
  }

  // bool is_new_axis = 8;
  if (this->_internal_is_new_axis() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_is_new_axis(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SliceProto)
  return target;
}

size_t SliceProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SliceProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 start = 2;
  if (this->_internal_start() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_start());
  }

  // int32 stop = 4;
  if (this->_internal_stop() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_stop());
  }

  // bool has_start = 1;
  if (this->_internal_has_start() != 0) {
    total_size += 1 + 1;
  }

  // bool has_stop = 3;
  if (this->_internal_has_stop() != 0) {
    total_size += 1 + 1;
  }

  // bool is_index = 6;
  if (this->_internal_is_index() != 0) {
    total_size += 1 + 1;
  }

  // bool is_ellipsis = 7;
  if (this->_internal_is_ellipsis() != 0) {
    total_size += 1 + 1;
  }

  // int32 step = 5;
  if (this->_internal_step() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_step());
  }

  // bool is_new_axis = 8;
  if (this->_internal_is_new_axis() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SliceProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SliceProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SliceProto::GetClassData() const { return &_class_data_; }

void SliceProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SliceProto *>(to)->MergeFrom(
      static_cast<const SliceProto &>(from));
}


void SliceProto::MergeFrom(const SliceProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SliceProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_start() != 0) {
    _internal_set_start(from._internal_start());
  }
  if (from._internal_stop() != 0) {
    _internal_set_stop(from._internal_stop());
  }
  if (from._internal_has_start() != 0) {
    _internal_set_has_start(from._internal_has_start());
  }
  if (from._internal_has_stop() != 0) {
    _internal_set_has_stop(from._internal_has_stop());
  }
  if (from._internal_is_index() != 0) {
    _internal_set_is_index(from._internal_is_index());
  }
  if (from._internal_is_ellipsis() != 0) {
    _internal_set_is_ellipsis(from._internal_is_ellipsis());
  }
  if (from._internal_step() != 0) {
    _internal_set_step(from._internal_step());
  }
  if (from._internal_is_new_axis() != 0) {
    _internal_set_is_new_axis(from._internal_is_new_axis());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SliceProto::CopyFrom(const SliceProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SliceProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SliceProto::IsInitialized() const {
  return true;
}

void SliceProto::InternalSwap(SliceProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SliceProto, is_new_axis_)
      + sizeof(SliceProto::is_new_axis_)
      - PROTOBUF_FIELD_OFFSET(SliceProto, start_)>(
          reinterpret_cast<char*>(&start_),
          reinterpret_cast<char*>(&other->start_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SliceProto::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_locator_2eproto_getter, &descriptor_table_locator_2eproto_once,
      file_level_metadata_locator_2eproto[0]);
}

// ===================================================================

class SelectorProto::_Internal {
 public:
};

SelectorProto::SelectorProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  slices_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:SelectorProto)
}
SelectorProto::SelectorProto(const SelectorProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      slices_(from.slices_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key(), 
      GetArenaForAllocation());
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:SelectorProto)
}

inline void SelectorProto::SharedCtor() {
key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
type_ = 0;
}

SelectorProto::~SelectorProto() {
  // @@protoc_insertion_point(destructor:SelectorProto)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SelectorProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SelectorProto::ArenaDtor(void* object) {
  SelectorProto* _this = reinterpret_cast< SelectorProto* >(object);
  (void)_this;
}
void SelectorProto::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SelectorProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SelectorProto::Clear() {
// @@protoc_insertion_point(message_clear_start:SelectorProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  slices_.Clear();
  key_.ClearToEmpty();
  type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SelectorProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .SelectorTypeProto type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::SelectorTypeProto>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .SliceProto slices = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_slices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "SelectorProto.key"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SelectorProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SelectorProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .SelectorTypeProto type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // repeated .SliceProto slices = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_slices_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_slices(i), target, stream);
  }

  // string key = 3;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SelectorProto.key");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SelectorProto)
  return target;
}

size_t SelectorProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SelectorProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SliceProto slices = 2;
  total_size += 1UL * this->_internal_slices_size();
  for (const auto& msg : this->slices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string key = 3;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // .SelectorTypeProto type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SelectorProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SelectorProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SelectorProto::GetClassData() const { return &_class_data_; }

void SelectorProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SelectorProto *>(to)->MergeFrom(
      static_cast<const SelectorProto &>(from));
}


void SelectorProto::MergeFrom(const SelectorProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SelectorProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  slices_.MergeFrom(from.slices_);
  if (!from._internal_key().empty()) {
    _internal_set_key(from._internal_key());
  }
  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SelectorProto::CopyFrom(const SelectorProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SelectorProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectorProto::IsInitialized() const {
  return true;
}

void SelectorProto::InternalSwap(SelectorProto* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  slices_.InternalSwap(&other->slices_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_, lhs_arena,
      &other->key_, rhs_arena
  );
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SelectorProto::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_locator_2eproto_getter, &descriptor_table_locator_2eproto_once,
      file_level_metadata_locator_2eproto[1]);
}

// ===================================================================

class MappingProto::_Internal {
 public:
};

MappingProto::MappingProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  agents_(arena),
  destination_(arena),
  source_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:MappingProto)
}
MappingProto::MappingProto(const MappingProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      agents_(from.agents_),
      destination_(from.destination_),
      source_(from.source_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&is_all_agents_, &from.is_all_agents_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_root_) -
    reinterpret_cast<char*>(&is_all_agents_)) + sizeof(is_root_));
  // @@protoc_insertion_point(copy_constructor:MappingProto)
}

inline void MappingProto::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&is_all_agents_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_root_) -
    reinterpret_cast<char*>(&is_all_agents_)) + sizeof(is_root_));
}

MappingProto::~MappingProto() {
  // @@protoc_insertion_point(destructor:MappingProto)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void MappingProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MappingProto::ArenaDtor(void* object) {
  MappingProto* _this = reinterpret_cast< MappingProto* >(object);
  (void)_this;
}
void MappingProto::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MappingProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MappingProto::Clear() {
// @@protoc_insertion_point(message_clear_start:MappingProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  agents_.Clear();
  destination_.Clear();
  source_.Clear();
  ::memset(&is_all_agents_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_root_) -
      reinterpret_cast<char*>(&is_all_agents_)) + sizeof(is_root_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MappingProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool is_all_agents = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          is_all_agents_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string agents = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_agents();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "MappingProto.agents"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool is_root = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          is_root_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .SelectorProto destination = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_destination(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .SelectorProto source = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_source(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MappingProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:MappingProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool is_all_agents = 1;
  if (this->_internal_is_all_agents() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_is_all_agents(), target);
  }

  // repeated string agents = 2;
  for (int i = 0, n = this->_internal_agents_size(); i < n; i++) {
    const auto& s = this->_internal_agents(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "MappingProto.agents");
    target = stream->WriteString(2, s, target);
  }

  // bool is_root = 3;
  if (this->_internal_is_root() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_is_root(), target);
  }

  // repeated .SelectorProto destination = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_destination_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_destination(i), target, stream);
  }

  // repeated .SelectorProto source = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_source_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_source(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MappingProto)
  return target;
}

size_t MappingProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MappingProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string agents = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(agents_.size());
  for (int i = 0, n = agents_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      agents_.Get(i));
  }

  // repeated .SelectorProto destination = 4;
  total_size += 1UL * this->_internal_destination_size();
  for (const auto& msg : this->destination_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .SelectorProto source = 5;
  total_size += 1UL * this->_internal_source_size();
  for (const auto& msg : this->source_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bool is_all_agents = 1;
  if (this->_internal_is_all_agents() != 0) {
    total_size += 1 + 1;
  }

  // bool is_root = 3;
  if (this->_internal_is_root() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MappingProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    MappingProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MappingProto::GetClassData() const { return &_class_data_; }

void MappingProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<MappingProto *>(to)->MergeFrom(
      static_cast<const MappingProto &>(from));
}


void MappingProto::MergeFrom(const MappingProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MappingProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  agents_.MergeFrom(from.agents_);
  destination_.MergeFrom(from.destination_);
  source_.MergeFrom(from.source_);
  if (from._internal_is_all_agents() != 0) {
    _internal_set_is_all_agents(from._internal_is_all_agents());
  }
  if (from._internal_is_root() != 0) {
    _internal_set_is_root(from._internal_is_root());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MappingProto::CopyFrom(const MappingProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MappingProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MappingProto::IsInitialized() const {
  return true;
}

void MappingProto::InternalSwap(MappingProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  agents_.InternalSwap(&other->agents_);
  destination_.InternalSwap(&other->destination_);
  source_.InternalSwap(&other->source_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MappingProto, is_root_)
      + sizeof(MappingProto::is_root_)
      - PROTOBUF_FIELD_OFFSET(MappingProto, is_all_agents_)>(
          reinterpret_cast<char*>(&is_all_agents_),
          reinterpret_cast<char*>(&other->is_all_agents_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MappingProto::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_locator_2eproto_getter, &descriptor_table_locator_2eproto_once,
      file_level_metadata_locator_2eproto[2]);
}

// ===================================================================

class LocatorProto::_Internal {
 public:
};

LocatorProto::LocatorProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  mappings_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:LocatorProto)
}
LocatorProto::LocatorProto(const LocatorProto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      mappings_(from.mappings_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:LocatorProto)
}

inline void LocatorProto::SharedCtor() {
}

LocatorProto::~LocatorProto() {
  // @@protoc_insertion_point(destructor:LocatorProto)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LocatorProto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LocatorProto::ArenaDtor(void* object) {
  LocatorProto* _this = reinterpret_cast< LocatorProto* >(object);
  (void)_this;
}
void LocatorProto::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LocatorProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LocatorProto::Clear() {
// @@protoc_insertion_point(message_clear_start:LocatorProto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mappings_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LocatorProto::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .MappingProto mappings = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_mappings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LocatorProto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:LocatorProto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .MappingProto mappings = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_mappings_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_mappings(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LocatorProto)
  return target;
}

size_t LocatorProto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LocatorProto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .MappingProto mappings = 1;
  total_size += 1UL * this->_internal_mappings_size();
  for (const auto& msg : this->mappings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LocatorProto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LocatorProto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LocatorProto::GetClassData() const { return &_class_data_; }

void LocatorProto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LocatorProto *>(to)->MergeFrom(
      static_cast<const LocatorProto &>(from));
}


void LocatorProto::MergeFrom(const LocatorProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:LocatorProto)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  mappings_.MergeFrom(from.mappings_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LocatorProto::CopyFrom(const LocatorProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LocatorProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocatorProto::IsInitialized() const {
  return true;
}

void LocatorProto::InternalSwap(LocatorProto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  mappings_.InternalSwap(&other->mappings_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LocatorProto::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_locator_2eproto_getter, &descriptor_table_locator_2eproto_once,
      file_level_metadata_locator_2eproto[3]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::SliceProto* Arena::CreateMaybeMessage< ::SliceProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SliceProto >(arena);
}
template<> PROTOBUF_NOINLINE ::SelectorProto* Arena::CreateMaybeMessage< ::SelectorProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SelectorProto >(arena);
}
template<> PROTOBUF_NOINLINE ::MappingProto* Arena::CreateMaybeMessage< ::MappingProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::MappingProto >(arena);
}
template<> PROTOBUF_NOINLINE ::LocatorProto* Arena::CreateMaybeMessage< ::LocatorProto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::LocatorProto >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
